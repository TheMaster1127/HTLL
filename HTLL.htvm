str str0 := ""
str str1 := ""
str str2 := ""
str str3 := ""
str str4 := ""
str str5 := ""
str str6 := ""
str str7 := ""
str str8 := ""
str str9 := ""
str str10 := ""
str str11 := ""
str str12 := ""
str str13 := ""
str str14 := ""
str str15 := ""
str str16 := ""
str str17 := ""
str str18 := ""
str str19 := ""
str str20 := ""
str main_syntax := "" . Chr(10) . "; =============================================================================" . Chr(10) . "; MAIN PROGRAM ENTRY POINT" . Chr(10) . "; =============================================================================" . Chr(10) . "_start:" . Chr(10) . "push rbp" . Chr(10) . "mov rbp, rsp" . Chr(10) . "and rsp, -16 " . Chr(10) . "mov rdi, args_array" . Chr(10) . "call array_clear" . Chr(10) . "mov r12, [rbp+8]" . Chr(10) . "lea r13, [rbp+16]" . Chr(10) . "mov r14, 1" . Chr(10) . ".arg_loop:" . Chr(10) . "cmp r14, r12" . Chr(10) . "jge .args_done" . Chr(10) . "mov rsi, [r13 + r14*8]" . Chr(10) . "mov rdi, args_array" . Chr(10) . "call array_unpack_from_bytes" . Chr(10) . "mov rdi, args_array" . Chr(10) . "mov rsi, 10" . Chr(10) . "call array_append" . Chr(10) . "inc r14" . Chr(10) . "jmp .arg_loop" . Chr(10) . ".args_done:" . Chr(10) . Chr(10)



func str SubStrLastChars(str text, int numOfChars) {
    str LastOut := ""
    int NumOfChars := 0
    Loop, Parse, text {
        NumOfChars++
    }
    Loop, % numOfChars {
        NumOfChars--
    }
    Loop, Parse, text {
        if (A_Index >= NumOfChars) {
            LastOut .= A_LoopField
        }
    }
    return LastOut
}

arr str nintArr
func bool isNint(str name) {
    Loop, % nintArr.size() {
        if (Trim(name) = Trim(nintArr[A_Index])) {
            return true
        }
    }
return false
}
func str compiler(str code) {
str out := ""

str HTLL_Libs_x86 := FileRead("HTLL_Libs_x86.txt")
int isDotCompile := 0


str dot_data := Chr(10)
str dot_data_print_temp_strings := Chr(10)
int dot_data_print_temp_strings_count := 0
str dot_data_ints := Chr(10)
str path_label := ""

str dot_bss := Chr(10)
str dot_bss_str := Chr(10)
str arrBss := ""

arr str theIdNumOfThe34theVar
arr str getAllCharForTheFurtureSoIcanAddEscapeChar
str ReplaceFixWhitOutFixDoubleQuotesInsideDoubleQuotes := ""
str str21 := ""
str htCodeOUT754754 := ""
str OutFixDoubleQuotesInsideDoubleQuotes := ""
str keyWordEscpaeChar := "\"
int fixOutFixDoubleQuotesInsideDoubleQuotesFIXok := 0
int removeNexFixkeyWordEscpaeChar := 0
int theIdNumOfThe34 := 0
int areWEinSome34sNum := 0

int loopCount := 0
int loopCount1 := 0
int loopCount2 := 0
int loopCount3 := 0
int loopCount4 := 0
int loopCount5 := 0
int loopCount6 := 0
int loopCount7 := 0
int loopCount8 := 0
int loopCount9 := 0
int ifCount := 0
int ifCount1 := 0
int ifCount2 := 0
int ifCount3 := 0
int ifCount4 := 0
int ifCount5 := 0
int ifCount6 := 0
int ifCount7 := 0
int ifCount8 := 0
int ifCount9 := 0
int funcCount := 0
int isNum := 0
int localVarNum := 1
int inFunc := 0
int funcArgsCount := 0
arr str funcArgsArr
str funcName := ""

str str_index := ""
str str_value := ""

int int1 := 0
int int2 := 0
int int3 := 0
int int4 := 0
int int5 := 0
int int6 := 0

Loop, Parse, code
{
theIdNumOfThe34theVar.add("")
theIdNumOfThe34theVar.add("")
}

Loop, Parse, code
{
theIdNumOfThe34theVar[A_Index] := theIdNumOfThe34theVar[A_Index] . Chr(34)
getAllCharForTheFurtureSoIcanAddEscapeChar.add(A_LoopField)
}

getAllCharForTheFurtureSoIcanAddEscapeChar.add(" ")

ReplaceFixWhitOutFixDoubleQuotesInsideDoubleQuotes := Chr(34) . "ihuiuuhuuhtheidFor" . str21 . "--" . str21 . "asds" . str21 . "as--" . str21 . "theuhtuwaesphoutr" . Chr(34)


Loop, Parse, code
{

if (A_LoopField = keyWordEscpaeChar) and (getAllCharForTheFurtureSoIcanAddEscapeChar[A_Index + 1] = Chr(34))
{
fixOutFixDoubleQuotesInsideDoubleQuotesFIXok := 1
OutFixDoubleQuotesInsideDoubleQuotes .= ReplaceFixWhitOutFixDoubleQuotesInsideDoubleQuotes
}
else
{
if (fixOutFixDoubleQuotesInsideDoubleQuotesFIXok != 1)
{
OutFixDoubleQuotesInsideDoubleQuotes .= A_LoopField
}
else
{
fixOutFixDoubleQuotesInsideDoubleQuotesFIXok := 0
}
}

}


code := OutFixDoubleQuotesInsideDoubleQuotes

if (keyWordEscpaeChar != Chr(92))
{
code := StrReplace(code, Chr(92), Chr(92) . Chr(92))
}




if (keyWordEscpaeChar = Chr(92))
{
Loop, Parse, code
{
if (A_LoopField = Chr(34))
{
areWEinSome34sNum++
}


if (areWEinSome34sNum = 1) 
{



if (A_LoopField != Chr(34))
{
if (A_LoopField = keyWordEscpaeChar)
{
theIdNumOfThe34theVar[theIdNumOfThe34] := theIdNumOfThe34theVar[theIdNumOfThe34] . Chr(92)
}
else
{
theIdNumOfThe34theVar[theIdNumOfThe34] := theIdNumOfThe34theVar[theIdNumOfThe34] . A_LoopField
}
}
else
{
theIdNumOfThe34++
htCodeOUT754754 .= "VYIGUOYIYVIUCFCYIUCFCYIGCYGICFHYFHCTCFTFDFGYGFC" . Chr(65) . Chr(65) . STR(theIdNumOfThe34) . Chr(65) . Chr(65)
}

}


if (areWEinSome34sNum = 2) or (areWEinSome34sNum = 0)
{
if (A_LoopField != Chr(34))
{
htCodeOUT754754 .= A_LoopField
}

areWEinSome34sNum := 0
}



}

}
else
{

Loop, Parse, code
{
if (A_LoopField = Chr(34))
{
areWEinSome34sNum++
}


if (areWEinSome34sNum = 1)
{



if (A_LoopField != Chr(34))
{
if (A_LoopField = keyWordEscpaeChar) and (keyWordEscpaeChar = getAllCharForTheFurtureSoIcanAddEscapeChar[A_Index + 1])
{
theIdNumOfThe34theVar[theIdNumOfThe34] := theIdNumOfThe34theVar[theIdNumOfThe34] . keyWordEscpaeChar
removeNexFixkeyWordEscpaeChar := 1
}
else if (A_LoopField = keyWordEscpaeChar)
{
if (removeNexFixkeyWordEscpaeChar != 1)
{
theIdNumOfThe34theVar[theIdNumOfThe34] := theIdNumOfThe34theVar[theIdNumOfThe34] . Chr(92)
}
else
{
removeNexFixkeyWordEscpaeChar := 0
}
}
else
{
theIdNumOfThe34theVar[theIdNumOfThe34] := theIdNumOfThe34theVar[theIdNumOfThe34] . A_LoopField
}

}
else
{
theIdNumOfThe34++
htCodeOUT754754 .= "VYIGUOYIYVIUCFCYIUCFCYIGCYGICFHYFHCTCFTFDFGYGFC" . Chr(65) . Chr(65) . STR(theIdNumOfThe34) . Chr(65) . Chr(65)

}

}


if (areWEinSome34sNum = 2) or (areWEinSome34sNum = 0)
{
if (A_LoopField != Chr(34))
{
htCodeOUT754754 .= A_LoopField
}

areWEinSome34sNum := 0
}



}
}






code := htCodeOUT754754

Loop, % theIdNumOfThe34
{
theIdNumOfThe34theVar[A_Index] := theIdNumOfThe34theVar[A_Index] . Chr(34)
}

theIdNumOfThe34theVar.add(Chr(34))







code := StrReplace(code, "{", Chr(10) . "{" . Chr(10))
code := StrReplace(code, "}", Chr(10) . "}" . Chr(10))
Loop, Parse, code, `n, `r
{
out .= Trim(A_LoopField) . Chr(10)
}
StringTrimRight, code, out, 1

str1 := ""
out := ""
Loop, Parse, code, `n, `r {
Loop, Parse, A_LoopField {

if (A_LoopField != ";") {
str1 .= A_LoopField
}
else {
break
}

}

out .= Trim(str1) . Chr(10)
str1 := ""
}
StringTrimRight, code, out, 1




int seenMain := 0
out := ""
Loop, Parse, code, `n, `r {

if (Trim(A_LoopField) = "main") {
seenMain := 1
out .= main_syntax . Chr(10)
}
else {
out .= A_LoopField . Chr(10)
}

}
StringTrimRight, code, out, 1



out := ""
Loop, Parse, code, `n, `r {
if (SubStr(A_LoopField, 1, 7) = "arradd ") {
str1 := Trim(StringTrimLeft(A_LoopField, 7))
str2 := StrSplit(str1, " ", 1)

str3 := StringTrimLeft(str1, StrLen(str2) + 1)

str4 := ""
Loop, Parse, str3 {
str4 .= "mov rsi, " . Chr(39) . A_LoopField . Chr(39) . Chr(10) . "mov rdi, " . str2 . Chr(10) . "call array_append" . Chr(10)
}

out .= str4 . Chr(10)
}
else if (SubStr(A_LoopField, 1, 4) = "int ") {
str1 := Trim(StringTrimLeft(A_LoopField, 4))



if (InStr(str1, ":="))
{
str2 := Trim(StrSplit(str1, ":=", 1))
str3 := Trim(StrSplit(str1, ":=", 2))

if (RegExMatch(str3, "^\d+$")) {
dot_data_ints .= str2 . " dq " . str3 . Chr(10)
}
else {
dot_data_ints .= str2 . " dq 0" . Chr(10)
out .= "mov rdi, [" . str3 . "]" . Chr(10)
out .= "mov [" . str2 . "], rdi" . Chr(10)

}


}
else {

if (InStr(str1, ":=") = false) and (InStr(str1, "+=") = false) and (InStr(str1, "-=") = false) and (InStr(str1, "*=") = false) {
dot_data_ints .= Trim(str1) . " dq 0" . Chr(10)
}
}



if (InStr(str1, "*="))
{
str2 := Trim(StrSplit(str1, "*=", 1))
str3 := Trim(StrSplit(str1, "*=", 2))
dot_data_ints .= str2 . " dq 0" . Chr(10)
}
else if (InStr(str1, "+="))
{
str2 := Trim(StrSplit(str1, "+=", 1))
str3 := Trim(StrSplit(str1, "+=", 2))
dot_data_ints .= str2 . " dq 0" . Chr(10)
}
else if (InStr(str1, "-="))
{
str2 := Trim(StrSplit(str1, "-=", 1))
str3 := Trim(StrSplit(str1, "-=", 2))
dot_data_ints .= str2 . " dq 0" . Chr(10)
}
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

if (InStr(A_LoopField, " += ")) {


str2 := Trim(StrSplit(str1, "+=", 1))
str3 := Trim(StrSplit(str1, "+=", 2))

if (RegExMatch(str3, "^\d+$")) {
out .= "add qword [" . str2 . "], " . str3 . Chr(10)
}
else {
out .= "mov rdi, [" . str3 . "]" . Chr(10)
out .= "add qword [" . str2 . "], rdi" . Chr(10)
}
}
else if (InStr(A_LoopField, " *= ")) {


    str2 := Trim(StrSplit(str1, "*=", 1))  ; var name
    str3 := Trim(StrSplit(str1, "*=", 2))  ; multiplier

    if (RegExMatch(str3, "^\d+$")) {
        ; *= constant
        out .= "mov rax, [" . str2 . "]" . Chr(10)
        out .= "imul rax, " . str3 . Chr(10)
        out .= "mov [" . str2 . "], rax" . Chr(10)
    }
    else {
        ; *= another variable
        out .= "mov rax, [" . str2 . "]" . Chr(10)
        out .= "imul rax, [" . str3 . "]" . Chr(10)
        out .= "mov [" . str2 . "], rax" . Chr(10)
    }
}
else if (InStr(A_LoopField, " -= ")) {

str2 := Trim(StrSplit(str1, "-=", 1))
str3 := Trim(StrSplit(str1, "-=", 2))

if (RegExMatch(str3, "^\d+$")) {
out .= "sub qword [" . str2 . "], " . str3 . Chr(10)
}
else {
out .= "mov rdi, [" . str3 . "]" . Chr(10)
out .= "sub qword [" . str2 . "], rdi" . Chr(10)
}
}

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

}
else if (SubStr(A_LoopField, 1, 5) = "nint ") {
str1 := Trim(StringTrimLeft(A_LoopField, 5))

if (InStr(str1, " ")) {
nintArr.add(StrSplit(str1, " ", 1))
}
else {
nintArr.add(Trim(str1))
}



if (InStr(str1, ":="))
{
str2 := Trim(StrSplit(str1, ":=", 1))
str3 := Trim(StrSplit(str1, ":=", 2))

if (RegExMatch(str3, "^\d+$")) {
dot_data_ints .= str2 . " dq " . str3 . Chr(10)
dot_data_ints .= str2 . "_is_negative: dq 0" . Chr(10)
}
else {
dot_data_ints .= str2 . " dq 0" . Chr(10)
dot_data_ints .= str2 . "_is_negative: dq 0" . Chr(10)
out .= "mov rdi, [" . str3 . "]" . Chr(10)
out .= "mov [" . str2 . "], rdi" . Chr(10)

}


}
else {

if (InStr(str1, ":=") = false) and (InStr(str1, "+=") = false) and (InStr(str1, "-=") = false) and (InStr(str1, "*=") = false) {
dot_data_ints .= Trim(str1) . " dq 0" . Chr(10)
dot_data_ints .= Trim(str1) . "_is_negative: dq 0" . Chr(10)
}
}



if (InStr(str1, "*="))
{
str2 := Trim(StrSplit(str1, "*=", 1))
str3 := Trim(StrSplit(str1, "*=", 2))
dot_data_ints .= str2 . " dq 0" . Chr(10)
dot_data_ints .= str2 . "_is_negative: dq 0" . Chr(10)
}
else if (InStr(str1, "+="))
{
str2 := Trim(StrSplit(str1, "+=", 1))
str3 := Trim(StrSplit(str1, "+=", 2))
dot_data_ints .= str2 . " dq 0" . Chr(10)
dot_data_ints .= str2 . "_is_negative: dq 0" . Chr(10)
}
else if (InStr(str1, "-="))
{
str2 := Trim(StrSplit(str1, "-=", 1))
str3 := Trim(StrSplit(str1, "-=", 2))
dot_data_ints .= str2 . " dq 0" . Chr(10)
dot_data_ints .= str2 . "_is_negative: dq 0" . Chr(10)
}
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

if (InStr(A_LoopField, " += ")) {


str2 := Trim(StrSplit(str1, "+=", 1))
str3 := Trim(StrSplit(str1, "+=", 2))

if (RegExMatch(str3, "^\d+$")) {
out .= "add qword [" . str2 . "], " . str3 . Chr(10)
out .= "lea rdi, [" . str2 . "]" . Chr(10) . "lea rsi, [" . str2 . "_is_negative]" . Chr(10) . "call is_nint_negative" . Chr(10)
}
else {
out .= "mov rdi, [" . str3 . "]" . Chr(10)
out .= "add qword [" . str2 . "], rdi" . Chr(10)
out .= "lea rdi, [" . str2 . "]" . Chr(10) . "lea rsi, [" . str2 . "_is_negative]" . Chr(10) . "call is_nint_negative" . Chr(10)
}
}
else if (InStr(A_LoopField, " *= ")) {


    str2 := Trim(StrSplit(str1, "*=", 1))  ; var name
    str3 := Trim(StrSplit(str1, "*=", 2))  ; multiplier

    if (RegExMatch(str3, "^\d+$")) {
        ; *= constant
        out .= "mov rax, [" . str2 . "]" . Chr(10)
        out .= "imul rax, " . str3 . Chr(10)
        out .= "mov [" . str2 . "], rax" . Chr(10)
        out .= "lea rdi, [" . str2 . "]" . Chr(10) . "lea rsi, [" . str2 . "_is_negative]" . Chr(10) . "call is_nint_negative" . Chr(10)
    }
    else {
        ; *= another variable
        out .= "mov rax, [" . str2 . "]" . Chr(10)
        out .= "imul rax, [" . str3 . "]" . Chr(10)
        out .= "mov [" . str2 . "], rax" . Chr(10)
        out .= "lea rdi, [" . str2 . "]" . Chr(10) . "lea rsi, [" . str2 . "_is_negative]" . Chr(10) . "call is_nint_negative" . Chr(10)
    }
}
else if (InStr(A_LoopField, " -= ")) {

str2 := Trim(StrSplit(str1, "-=", 1))
str3 := Trim(StrSplit(str1, "-=", 2))

if (RegExMatch(str3, "^\d+$")) {
out .= "sub qword [" . str2 . "], " . str3 . Chr(10)
out .= "lea rdi, [" . str2 . "]" . Chr(10) . "lea rsi, [" . str2 . "_is_negative]" . Chr(10) . "call is_nint_negative" . Chr(10)
}
else {
out .= "mov rdi, [" . str3 . "]" . Chr(10)
out .= "sub qword [" . str2 . "], rdi" . Chr(10)
out .= "lea rdi, [" . str2 . "]" . Chr(10) . "lea rsi, [" . str2 . "_is_negative]" . Chr(10) . "call is_nint_negative" . Chr(10)
}
}

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

}
else if (SubStr(A_LoopField, 1, 4) = "str ") {
str1 := Trim(StringTrimLeft(A_LoopField, 4))


str2 := Trim(StrSplit(str1, "[", 2))
str2 := Trim(StrSplit(str2, "]", 1))
str1 := Trim(StrSplit(str1, "[", 1))

dot_bss_str .= str1 . " rb " . str2 . Chr(10)


}
else if (InStr(A_LoopField, " := ")) or (InStr(A_LoopField, " += ")) or (InStr(A_LoopField, " -= ")) or (InStr(A_LoopField, " *= ")) {

if (InStr(A_LoopField, " := ")) {

str1 := Trim(A_LoopField)
str2 := Trim(StrSplit(str1, ":=", 1))
str3 := Trim(StrSplit(str1, ":=", 2))

if (RegExMatch(str3, "^\d+$")) {
out .= "mov qword [" . str2 . "], " . str3 . Chr(10)
if (isNint(str2)) {
out .= "lea rdi, [" . str2 . "]" . Chr(10) . "lea rsi, [" . str2 . "_is_negative]" . Chr(10) . "call is_nint_negative" . Chr(10)
}
}
else {
out .= "mov rdi, [" . str3 . "]" . Chr(10)
out .= "mov [" . str2 . "], rdi" . Chr(10)
if (isNint(str2)) {
out .= "lea rdi, [" . str2 . "]" . Chr(10) . "lea rsi, [" . str2 . "_is_negative]" . Chr(10) . "call is_nint_negative" . Chr(10)
}
}
}
else if (InStr(A_LoopField, " += ")) {

str1 := Trim(A_LoopField)
str2 := Trim(StrSplit(str1, "+=", 1))
str3 := Trim(StrSplit(str1, "+=", 2))

if (RegExMatch(str3, "^\d+$")) {
out .= "add qword [" . str2 . "], " . str3 . Chr(10)
if (isNint(str2)) {
out .= "lea rdi, [" . str2 . "]" . Chr(10) . "lea rsi, [" . str2 . "_is_negative]" . Chr(10) . "call is_nint_negative" . Chr(10)
}
}
else {
out .= "mov rdi, [" . str3 . "]" . Chr(10)
out .= "add qword [" . str2 . "], rdi" . Chr(10)
if (isNint(str2)) {
out .= "lea rdi, [" . str2 . "]" . Chr(10) . "lea rsi, [" . str2 . "_is_negative]" . Chr(10) . "call is_nint_negative" . Chr(10)
}
}
}
else if (InStr(A_LoopField, " *= ")) {

    str1 := Trim(A_LoopField)
    str2 := Trim(StrSplit(str1, "*=", 1))  ; var name
    str3 := Trim(StrSplit(str1, "*=", 2))  ; multiplier

    if (RegExMatch(str3, "^\d+$")) {
        ; *= constant
        out .= "mov rax, [" . str2 . "]" . Chr(10)
        out .= "imul rax, " . str3 . Chr(10)
        out .= "mov [" . str2 . "], rax" . Chr(10)
        if (isNint(str2)) {
out .= "lea rdi, [" . str2 . "]" . Chr(10) . "lea rsi, [" . str2 . "_is_negative]" . Chr(10) . "call is_nint_negative" . Chr(10)
}
    }
    else {
        ; *= another variable
        out .= "mov rax, [" . str2 . "]" . Chr(10)
        out .= "imul rax, [" . str3 . "]" . Chr(10)
        out .= "mov [" . str2 . "], rax" . Chr(10)
        if (isNint(str2)) {
out .= "lea rdi, [" . str2 . "]" . Chr(10) . "lea rsi, [" . str2 . "_is_negative]" . Chr(10) . "call is_nint_negative" . Chr(10)
}
    }
}
else if (InStr(A_LoopField, " -= ")) {

str1 := Trim(A_LoopField)
str2 := Trim(StrSplit(str1, "-=", 1))
str3 := Trim(StrSplit(str1, "-=", 2))

if (RegExMatch(str3, "^\d+$")) {
out .= "sub qword [" . str2 . "], " . str3 . Chr(10)
if (isNint(str2)) {
out .= "lea rdi, [" . str2 . "]" . Chr(10) . "lea rsi, [" . str2 . "_is_negative]" . Chr(10) . "call is_nint_negative" . Chr(10)
}
}
else {
out .= "mov rdi, [" . str3 . "]" . Chr(10)
out .= "sub qword [" . str2 . "], rdi" . Chr(10)
if (isNint(str2)) {
out .= "lea rdi, [" . str2 . "]" . Chr(10) . "lea rsi, [" . str2 . "_is_negative]" . Chr(10) . "call is_nint_negative" . Chr(10)
}
}
}


}
else if (InStr(A_LoopField, "++")) {
str1 := Trim(A_LoopField)
StringTrimRight, str1, str1, 2
out .= "inc qword [" . Trim(str1) . "]" . Chr(10)
if (isNint(str1)) {
out .= "lea rdi, [" . str1 . "]" . Chr(10) . "lea rsi, [" . str1 . "_is_negative]" . Chr(10) . "call is_nint_negative" . Chr(10)
}
}
else if (InStr(A_LoopField, "--")) {
str1 := Trim(A_LoopField)
StringTrimRight, str1, str1, 2
out .= "dec qword [" . Trim(str1) . "]" . Chr(10)
if (isNint(str1)) {
out .= "lea rdi, [" . str1 . "]" . Chr(10) . "lea rsi, [" . str1 . "_is_negative]" . Chr(10) . "call is_nint_negative" . Chr(10)
}
}
else if (SubStr(A_LoopField, 1, 6) = "print(") {
str1 := StringTrimLeft(A_LoopField, 6)
StringTrimRight, str1, str1, 1
if (RegExMatch(str1, "^\d+$")) {
out .= "mov rdi, " . Trim(str1) . Chr(10) . "mov rsi, 0" . Chr(10) . "call print_number" . Chr(10)
}
else if (InStr(str1, "VYIGUOYIYVIUCFCYIUCFCYIGCYGICFHYFHCTCFTFDFGYGFC")) {
dot_data_print_temp_strings_count++
dot_data_print_temp_strings .= "ASM_STR_TEMP_PRINT_" . STR(dot_data_print_temp_strings_count) . " db " . Trim(str1) . ", 10" . Chr(10) . "ASM_STR_TEMP_PRINT_" . STR(dot_data_print_temp_strings_count) . "_len = $-" . "ASM_STR_TEMP_PRINT_" . STR(dot_data_print_temp_strings_count) . Chr(10)


out .= "mov rsi, ASM_STR_TEMP_PRINT_" . STR(dot_data_print_temp_strings_count) . Chr(10) . "mov rdx, " . "ASM_STR_TEMP_PRINT_" . STR(dot_data_print_temp_strings_count) . "_len" . Chr(10) . "call print_str" . Chr(10)


}
else {


if (isNint(str1)) {
out .= "mov rdi, [" . Trim(str1) . "]" . Chr(10) . "mov rsi, [" . str2 . "_is_negative]" . Chr(10) . "call print_number" . Chr(10)
}
else {
out .= "mov rdi, [" . Trim(str1) . "]" . Chr(10) . "mov rsi, 0" . Chr(10) . "call print_number" . Chr(10)
}


}

}
else if (Trim(A_LoopField) = "print_rax_as_char") {
out .= "mov rdi, rax" . Chr(10) . "push rcx" . Chr(10) . "call print_char" . Chr(10) . "pop rcx" . Chr(10)
}







else if (StrLower(Trim(A_LoopField)) = "continue") or (StrLower(Trim(A_LoopField)) = "continue1") {
    out .= "jmp .cloop1_end" . STR(loopCount1) . Chr(10)
}
else if (StrLower(Trim(A_LoopField)) = "continue2") {
    out .= "jmp .cloop2_end" . STR(loopCount2) . Chr(10)
}
else if (StrLower(Trim(A_LoopField)) = "continue3") {
    out .= "jmp .cloop3_end" . STR(loopCount3) . Chr(10)
}
else if (StrLower(Trim(A_LoopField)) = "continue4") {
    out .= "jmp .cloop4_end" . STR(loopCount4) . Chr(10)
}
else if (StrLower(Trim(A_LoopField)) = "continue5") {
    out .= "jmp .cloop5_end" . STR(loopCount5) . Chr(10)
}
else if (StrLower(Trim(A_LoopField)) = "continue6") {
    out .= "jmp .cloop6_end" . STR(loopCount6) . Chr(10)
}
else if (StrLower(Trim(A_LoopField)) = "continue7") {
    out .= "jmp .cloop7_end" . STR(loopCount7) . Chr(10)
}
else if (StrLower(Trim(A_LoopField)) = "continue8") {
    out .= "jmp .cloop8_end" . STR(loopCount8) . Chr(10)
}
else if (StrLower(Trim(A_LoopField)) = "continue9") {
    out .= "jmp .cloop9_end" . STR(loopCount9) . Chr(10)
}



else if (StrLower(Trim(A_LoopField)) = "break") or (StrLower(Trim(A_LoopField)) = "break1") {
    out .= "jmp .loop1_end" . STR(loopCount1) . Chr(10)
}
else if (StrLower(Trim(A_LoopField)) = "break2") {
    out .= "jmp .loop2_end" . STR(loopCount2) . Chr(10)
}
else if (StrLower(Trim(A_LoopField)) = "break3") {
    out .= "jmp .loop3_end" . STR(loopCount3) . Chr(10)
}
else if (StrLower(Trim(A_LoopField)) = "break4") {
    out .= "jmp .loop4_end" . STR(loopCount4) . Chr(10)
}
else if (StrLower(Trim(A_LoopField)) = "break5") {
    out .= "jmp .loop5_end" . STR(loopCount5) . Chr(10)
}
else if (StrLower(Trim(A_LoopField)) = "break6") {
    out .= "jmp .loop6_end" . STR(loopCount6) . Chr(10)
}
else if (StrLower(Trim(A_LoopField)) = "break7") {
    out .= "jmp .loop7_end" . STR(loopCount7) . Chr(10)
}
else if (StrLower(Trim(A_LoopField)) = "break8") {
    out .= "jmp .loop8_end" . STR(loopCount8) . Chr(10)
}
else if (StrLower(Trim(A_LoopField)) = "break9") {
    out .= "jmp .loop9_end" . STR(loopCount9) . Chr(10)
}




else if (SubStr(StrLower(A_LoopField), 1, 6) = "loop, ") or (SubStr(StrLower(A_LoopField), 1, 7) = "loop1, ") {
    str1 := Trim(StringTrimLeft(Trim(A_LoopField), 6))
    if (RegExMatch(str1, "^\d+$")) {
        out .= "push r12" . Chr(10) . "push r13" . Chr(10) . "xor r13, r13" . Chr(10) . "mov r12, " . str1 . Chr(10) . ".loop1_" . STR(loopCount1) . ":" . Chr(10) . "cmp r12, 0" . Chr(10) . "je .loop1_end" . STR(loopCount1) . Chr(10)
    }
    else {
        out .= "push r12" . Chr(10) . "push r13" . Chr(10) . "xor r13, r13" . Chr(10) . "mov r12, [" . str1 . "]" . Chr(10) . ".loop1_" . STR(loopCount1) . ":" . Chr(10) . "cmp r12, 0" . Chr(10) . "je .loop1_end" . STR(loopCount1) . Chr(10)
    }
}
else if (Trim(A_LoopField) = "loopend") or (Trim(A_LoopField) = "endloop") or (Trim(A_LoopField) = "loopend1") or (Trim(A_LoopField) = "endloop1") {
    out .= ".cloop1_end" . STR(loopCount1) . ":" . Chr(10) . "inc r13" . Chr(10) . "dec r12" . Chr(10) . "jmp .loop1_" . STR(loopCount1) . Chr(10) . ".loop1_end" . STR(loopCount1) . ":" . Chr(10) . "pop r13" . Chr(10) . "pop r12" . Chr(10)
    loopCount1++
}
else if (SubStr(StrLower(A_LoopField), 1, 7) = "loop2, ") {
    str1 := Trim(StringTrimLeft(Trim(A_LoopField), 7))
    if (RegExMatch(str1, "^\d+$")) {
        out .= "push r12" . Chr(10) . "push r13" . Chr(10) . "xor r13, r13" . Chr(10) . "mov r12, " . str1 . Chr(10) . ".loop2_" . STR(loopCount2) . ":" . Chr(10) . "cmp r12, 0" . Chr(10) . "je .loop2_end" . STR(loopCount2) . Chr(10)
    }
    else {
        out .= "push r12" . Chr(10) . "push r13" . Chr(10) . "xor r13, r13" . Chr(10) . "mov r12, [" . str1 . "]" . Chr(10) . ".loop2_" . STR(loopCount2) . ":" . Chr(10) . "cmp r12, 0" . Chr(10) . "je .loop2_end" . STR(loopCount2) . Chr(10)
    }
}
else if (Trim(A_LoopField) = "loopend2") or (Trim(A_LoopField) = "endloop2") {
    out .= ".cloop2_end" . STR(loopCount2) . ":" . Chr(10) . "inc r13" . Chr(10) . "dec r12" . Chr(10) . "jmp .loop2_" . STR(loopCount2) . Chr(10) . ".loop2_end" . STR(loopCount2) . ":" . Chr(10) . "pop r13" . Chr(10) . "pop r12" . Chr(10)
    loopCount2++
}
else if (SubStr(StrLower(A_LoopField), 1, 7) = "loop3, ") {
    str1 := Trim(StringTrimLeft(Trim(A_LoopField), 7))
    if (RegExMatch(str1, "^\d+$")) {
        out .= "push r12" . Chr(10) . "push r13" . Chr(10) . "xor r13, r13" . Chr(10) . "mov r12, " . str1 . Chr(10) . ".loop3_" . STR(loopCount3) . ":" . Chr(10) . "cmp r12, 0" . Chr(10) . "je .loop3_end" . STR(loopCount3) . Chr(10)
    }
    else {
        out .= "push r12" . Chr(10) . "push r13" . Chr(10) . "xor r13, r13" . Chr(10) . "mov r12, [" . str1 . "]" . Chr(10) . ".loop3_" . STR(loopCount3) . ":" . Chr(10) . "cmp r12, 0" . Chr(10) . "je .loop3_end" . STR(loopCount3) . Chr(10)
    }
}
else if (Trim(A_LoopField) = "loopend3") or (Trim(A_LoopField) = "endloop3") {
    out .= ".cloop3_end" . STR(loopCount3) . ":" . Chr(10) . "inc r13" . Chr(10) . "dec r12" . Chr(10) . "jmp .loop3_" . STR(loopCount3) . Chr(10) . ".loop3_end" . STR(loopCount3) . ":" . Chr(10) . "pop r13" . Chr(10) . "pop r12" . Chr(10)
    loopCount3++
}
else if (SubStr(StrLower(A_LoopField), 1, 7) = "loop4, ") {
    str1 := Trim(StringTrimLeft(Trim(A_LoopField), 7))
    if (RegExMatch(str1, "^\d+$")) {
        out .= "push r12" . Chr(10) . "push r13" . Chr(10) . "xor r13, r13" . Chr(10) . "mov r12, " . str1 . Chr(10) . ".loop4_" . STR(loopCount4) . ":" . Chr(10) . "cmp r12, 0" . Chr(10) . "je .loop4_end" . STR(loopCount4) . Chr(10)
    }
    else {
        out .= "push r12" . Chr(10) . "push r13" . Chr(10) . "xor r13, r13" . Chr(10) . "mov r12, [" . str1 . "]" . Chr(10) . ".loop4_" . STR(loopCount4) . ":" . Chr(10) . "cmp r12, 0" . Chr(10) . "je .loop4_end" . STR(loopCount4) . Chr(10)
    }
}
else if (Trim(A_LoopField) = "loopend4") or (Trim(A_LoopField) = "endloop4") {
    out .= ".cloop4_end" . STR(loopCount4) . ":" . Chr(10) . "inc r13" . Chr(10) . "dec r12" . Chr(10) . "jmp .loop4_" . STR(loopCount4) . Chr(10) . ".loop4_end" . STR(loopCount4) . ":" . Chr(10) . "pop r13" . Chr(10) . "pop r12" . Chr(10)
    loopCount4++
}
else if (SubStr(StrLower(A_LoopField), 1, 7) = "loop5, ") {
    str1 := Trim(StringTrimLeft(Trim(A_LoopField), 7))
    if (RegExMatch(str1, "^\d+$")) {
        out .= "push r12" . Chr(10) . "push r13" . Chr(10) . "xor r13, r13" . Chr(10) . "mov r12, " . str1 . Chr(10) . ".loop5_" . STR(loopCount5) . ":" . Chr(10) . "cmp r12, 0" . Chr(10) . "je .loop5_end" . STR(loopCount5) . Chr(10)
    }
    else {
        out .= "push r12" . Chr(10) . "push r13" . Chr(10) . "xor r13, r13" . Chr(10) . "mov r12, [" . str1 . "]" . Chr(10) . ".loop5_" . STR(loopCount5) . ":" . Chr(10) . "cmp r12, 0" . Chr(10) . "je .loop5_end" . STR(loopCount5) . Chr(10)
    }
}
else if (Trim(A_LoopField) = "loopend5") or (Trim(A_LoopField) = "endloop5") {
    out .= ".cloop5_end" . STR(loopCount5) . ":" . Chr(10) . "inc r13" . Chr(10) . "dec r12" . Chr(10) . "jmp .loop5_" . STR(loopCount5) . Chr(10) . ".loop5_end" . STR(loopCount5) . ":" . Chr(10) . "pop r13" . Chr(10) . "pop r12" . Chr(10)
    loopCount5++
}
else if (SubStr(StrLower(A_LoopField), 1, 7) = "loop6, ") {
    str1 := Trim(StringTrimLeft(Trim(A_LoopField), 7))
    if (RegExMatch(str1, "^\d+$")) {
        out .= "push r12" . Chr(10) . "push r13" . Chr(10) . "xor r13, r13" . Chr(10) . "mov r12, " . str1 . Chr(10) . ".loop6_" . STR(loopCount6) . ":" . Chr(10) . "cmp r12, 0" . Chr(10) . "je .loop6_end" . STR(loopCount6) . Chr(10)
    }
    else {
        out .= "push r12" . Chr(10) . "push r13" . Chr(10) . "xor r13, r13" . Chr(10) . "mov r12, [" . str1 . "]" . Chr(10) . ".loop6_" . STR(loopCount6) . ":" . Chr(10) . "cmp r12, 0" . Chr(10) . "je .loop6_end" . STR(loopCount6) . Chr(10)
    }
}
else if (Trim(A_LoopField) = "loopend6") or (Trim(A_LoopField) = "endloop6") {
    out .= ".cloop6_end" . STR(loopCount6) . ":" . Chr(10) . "inc r13" . Chr(10) . "dec r12" . Chr(10) . "jmp .loop6_" . STR(loopCount6) . Chr(10) . ".loop6_end" . STR(loopCount6) . ":" . Chr(10) . "pop r13" . Chr(10) . "pop r12" . Chr(10)
    loopCount6++
}
else if (SubStr(StrLower(A_LoopField), 1, 7) = "loop7, ") {
    str1 := Trim(StringTrimLeft(Trim(A_LoopField), 7))
    if (RegExMatch(str1, "^\d+$")) {
        out .= "push r12" . Chr(10) . "push r13" . Chr(10) . "xor r13, r13" . Chr(10) . "mov r12, " . str1 . Chr(10) . ".loop7_" . STR(loopCount7) . ":" . Chr(10) . "cmp r12, 0" . Chr(10) . "je .loop7_end" . STR(loopCount7) . Chr(10)
    }
    else {
        out .= "push r12" . Chr(10) . "push r13" . Chr(10) . "xor r13, r13" . Chr(10) . "mov r12, [" . str1 . "]" . Chr(10) . ".loop7_" . STR(loopCount7) . ":" . Chr(10) . "cmp r12, 0" . Chr(10) . "je .loop7_end" . STR(loopCount7) . Chr(10)
    }
}
else if (Trim(A_LoopField) = "loopend7") or (Trim(A_LoopField) = "endloop7") {
    out .= ".cloop7_end" . STR(loopCount7) . ":" . Chr(10) . "inc r13" . Chr(10) . "dec r12" . Chr(10) . "jmp .loop7_" . STR(loopCount7) . Chr(10) . ".loop7_end" . STR(loopCount7) . ":" . Chr(10) . "pop r13" . Chr(10) . "pop r12" . Chr(10)
    loopCount7++
}
else if (SubStr(StrLower(A_LoopField), 1, 7) = "loop8, ") {
    str1 := Trim(StringTrimLeft(Trim(A_LoopField), 7))
    if (RegExMatch(str1, "^\d+$")) {
        out .= "push r12" . Chr(10) . "push r13" . Chr(10) . "xor r13, r13" . Chr(10) . "mov r12, " . str1 . Chr(10) . ".loop8_" . STR(loopCount8) . ":" . Chr(10) . "cmp r12, 0" . Chr(10) . "je .loop8_end" . STR(loopCount8) . Chr(10)
    }
    else {
        out .= "push r12" . Chr(10) . "push r13" . Chr(10) . "xor r13, r13" . Chr(10) . "mov r12, [" . str1 . "]" . Chr(10) . ".loop8_" . STR(loopCount8) . ":" . Chr(10) . "cmp r12, 0" . Chr(10) . "je .loop8_end" . STR(loopCount8) . Chr(10)
    }
}
else if (Trim(A_LoopField) = "loopend8") or (Trim(A_LoopField) = "endloop8") {
    out .= ".cloop8_end" . STR(loopCount8) . ":" . Chr(10) . "inc r13" . Chr(10) . "dec r12" . Chr(10) . "jmp .loop8_" . STR(loopCount8) . Chr(10) . ".loop8_end" . STR(loopCount8) . ":" . Chr(10) . "pop r13" . Chr(10) . "pop r12" . Chr(10)
    loopCount8++
}
else if (SubStr(StrLower(A_LoopField), 1, 7) = "loop9, ") {
    str1 := Trim(StringTrimLeft(Trim(A_LoopField), 7))
    if (RegExMatch(str1, "^\d+$")) {
        out .= "push r12" . Chr(10) . "push r13" . Chr(10) . "xor r13, r13" . Chr(10) . "mov r12, " . str1 . Chr(10) . ".loop9_" . STR(loopCount9) . ":" . Chr(10) . "cmp r12, 0" . Chr(10) . "je .loop9_end" . STR(loopCount9) . Chr(10)
    }
    else {
        out .= "push r12" . Chr(10) . "push r13" . Chr(10) . "xor r13, r13" . Chr(10) . "mov r12, [" . str1 . "]" . Chr(10) . ".loop9_" . STR(loopCount9) . ":" . Chr(10) . "cmp r12, 0" . Chr(10) . "je .loop9_end" . STR(loopCount9) . Chr(10)
    }
}
else if (Trim(A_LoopField) = "loopend9") or (Trim(A_LoopField) = "endloop9") {
    out .= ".cloop9_end" . STR(loopCount9) . ":" . Chr(10) . "inc r13" . Chr(10) . "dec r12" . Chr(10) . "jmp .loop9_" . STR(loopCount9) . Chr(10) . ".loop9_end" . STR(loopCount9) . ":" . Chr(10) . "pop r13" . Chr(10) . "pop r12" . Chr(10)
    loopCount9++
}
else if (SubStr(StrLower(A_LoopField), 1, 3) = "if ") or (SubStr(StrLower(A_LoopField), 1, 4) = "if1 ") {
    str1 := Trim(StringTrimLeft(A_LoopField, 3))
    str1 := StringTrimLeft(str1, 1)
    str1 := StringTrimRight(str1, 1)
    isNum := 0
    if (InStr(str1, " = ")) {
        str2 := Trim(StrSplit(str1, " = ", 1))
        str3 := Trim(StrSplit(str1, " = ", 2))
        if (RegExMatch(str3, "^\d+$")) {
            isNum := 1
        }
        if (isNum = 1) {
            out .= "mov rax, [" . str2 . "]" . Chr(10) . "cmp rax, " . str3 . Chr(10) . "jne .end_if1_" . STR(ifCount1) . Chr(10)
        }
        else {
            out .= "mov rax, [" . str2 . "]" . Chr(10) . "cmp rax, [" . str3 . "]" . Chr(10) . "jne .end_if1_" . STR(ifCount1) . Chr(10)
        }
    }
    else if (InStr(str1, " != ")) {
        str2 := Trim(StrSplit(str1, " != ", 1))
        str3 := Trim(StrSplit(str1, " != ", 2))
        if (RegExMatch(str3, "^\d+$")) {
            isNum := 1
        }
        if (isNum = 1) {
            out .= "mov rax, [" . str2 . "]" . Chr(10) . "cmp rax, " . str3 . Chr(10) . "je .end_if1_" . STR(ifCount1) . Chr(10)
        }
        else {
            out .= "mov rax, [" . str2 . "]" . Chr(10) . "cmp rax, [" . str3 . "]" . Chr(10) . "je .end_if1_" . STR(ifCount1) . Chr(10)
        }
    }
    if (InStr(str1, " > ")) {
    str2 := Trim(StrSplit(str1, " > ", 1))
    str3 := Trim(StrSplit(str1, " > ", 2))
    isNum := 0
    if (RegExMatch(str3, "^\d+$")) {
        isNum := 1
    }
    if (isNum = 1) {
        out .= "mov rax, [" . str2 . "]" . Chr(10)
        out .= "cmp rax, " . str3 . Chr(10)
        out .= "jle .end_if1_" . STR(ifCount1) . Chr(10)
    } else {
        out .= "mov rax, [" . str2 . "]" . Chr(10)
        out .= "cmp rax, [" . str3 . "]" . Chr(10)
        out .= "jle .end_if1_" . STR(ifCount1) . Chr(10)
    }
} else if (InStr(str1, " < ")) {
    str2 := Trim(StrSplit(str1, " < ", 1))
    str3 := Trim(StrSplit(str1, " < ", 2))
    isNum := 0
    if (RegExMatch(str3, "^\d+$")) {
        isNum := 1
    }
    if (isNum = 1) {
        out .= "mov rax, [" . str2 . "]" . Chr(10)
        out .= "cmp rax, " . str3 . Chr(10)
        out .= "jge .end_if1_" . STR(ifCount1) . Chr(10)
    } else {
        out .= "mov rax, [" . str2 . "]" . Chr(10)
        out .= "cmp rax, [" . str3 . "]" . Chr(10)
        out .= "jge .end_if1_" . STR(ifCount1) . Chr(10)
    }
} else if (InStr(str1, " >= ")) {
    str2 := Trim(StrSplit(str1, " >= ", 1))
    str3 := Trim(StrSplit(str1, " >= ", 2))
    isNum := 0
    if (RegExMatch(str3, "^\d+$")) {
        isNum := 1
    }
    if (isNum = 1) {
        out .= "mov rax, [" . str2 . "]" . Chr(10)
        out .= "cmp rax, " . str3 . Chr(10)
        out .= "jl .end_if1_" . STR(ifCount1) . Chr(10)
    } else {
        out .= "mov rax, [" . str2 . "]" . Chr(10)
        out .= "cmp rax, [" . str3 . "]" . Chr(10)
        out .= "jl .end_if1_" . STR(ifCount1) . Chr(10)
    }
} else if (InStr(str1, " <= ")) {
    str2 := Trim(StrSplit(str1, " <= ", 1))
    str3 := Trim(StrSplit(str1, " <= ", 2))
    isNum := 0
    if (RegExMatch(str3, "^\d+$")) {
        isNum := 1
    }
    if (isNum = 1) {
        out .= "mov rax, [" . str2 . "]" . Chr(10)
        out .= "cmp rax, " . str3 . Chr(10)
        out .= "jg .end_if1_" . STR(ifCount1) . Chr(10)
    } else {
        out .= "mov rax, [" . str2 . "]" . Chr(10)
        out .= "cmp rax, [" . str3 . "]" . Chr(10)
        out .= "jg .end_if1_" . STR(ifCount1) . Chr(10)
    }
}

}
else if (Trim(A_LoopField) = "ifend") or (Trim(A_LoopField) = "endif") or (Trim(A_LoopField) = "ifend1") or (Trim(A_LoopField) = "endif1") {
    out .= ".end_if1_" . STR(ifCount1) . ":" . Chr(10)
    ifCount1++
}
else if (SubStr(StrLower(A_LoopField), 1, 4) = "if2 ") {
    str1 := Trim(StringTrimLeft(A_LoopField, 4)) ; str1
    str1 := StringTrimLeft(str1, 1)
    str1 := StringTrimRight(str1, 1)
    if (InStr(str1, " = ")) {
        str2 := Trim(StrSplit(str1, " = ", 1)) ; str3
        if (RegExMatch(str3, "^\d+$")) {
            isNum := 1
        }
        if (isNum = 1) {
            out .= "mov rax, [" . str2 . "]" . Chr(10) . "cmp rax, " . str3 . Chr(10) . "jne .end_if2_" . STR(ifCount2) . Chr(10)
        }
        else {
            out .= "mov rax, [" . str2 . "]" . Chr(10) . "cmp rax, [" . str3 . "]" . Chr(10) . "jne .end_if2_" . STR(ifCount2) . Chr(10)
        }
    }
    else if (InStr(str1, " != ")) {
        str2 := Trim(StrSplit(str1, " != ", 1)) ; str3
        if (RegExMatch(str3, "^\d+$")) {
            isNum := 1
        }
        if (isNum = 1) {
            out .= "mov rax, [" . str2 . "]" . Chr(10) . "cmp rax, " . str3 . Chr(10) . "je .end_if2_" . STR(ifCount2) . Chr(10)
        }
        else {
            out .= "mov rax, [" . str2 . "]" . Chr(10) . "cmp rax, [" . str3 . "]" . Chr(10) . "je .end_if2_" . STR(ifCount2) . Chr(10)
        }
    }
    ; --- IF2 ---
if (InStr(str1, " > ")) {
    str2 := Trim(StrSplit(str1, " > ", 1))
    str3 := Trim(StrSplit(str1, " > ", 2))
    isNum := 0
    if (RegExMatch(str3, "^\d+$")) { isNum := 1 }
    if (isNum = 1) {
        out .= "mov rax, [" . str2 . "]" . Chr(10)
        out .= "cmp rax, " . str3 . Chr(10)
        out .= "jle .end_if2_" . STR(ifCount2) . Chr(10)
    } else {
        out .= "mov rax, [" . str2 . "]" . Chr(10)
        out .= "cmp rax, [" . str3 . "]" . Chr(10)
        out .= "jle .end_if2_" . STR(ifCount2) . Chr(10)
    }
} else if (InStr(str1, " < ")) {
    str2 := Trim(StrSplit(str1, " < ", 1))
    str3 := Trim(StrSplit(str1, " < ", 2))
    isNum := 0
    if (RegExMatch(str3, "^\d+$")) { isNum := 1 }
    if (isNum = 1) {
        out .= "mov rax, [" . str2 . "]" . Chr(10)
        out .= "cmp rax, " . str3 . Chr(10)
        out .= "jge .end_if2_" . STR(ifCount2) . Chr(10)
    } else {
        out .= "mov rax, [" . str2 . "]" . Chr(10)
        out .= "cmp rax, [" . str3 . "]" . Chr(10)
        out .= "jge .end_if2_" . STR(ifCount2) . Chr(10)
    }
} else if (InStr(str1, " >= ")) {
    str2 := Trim(StrSplit(str1, " >= ", 1))
    str3 := Trim(StrSplit(str1, " >= ", 2))
    isNum := 0
    if (RegExMatch(str3, "^\d+$")) { isNum := 1 }
    if (isNum = 1) {
        out .= "mov rax, [" . str2 . "]" . Chr(10)
        out .= "cmp rax, " . str3 . Chr(10)
        out .= "jl .end_if2_" . STR(ifCount2) . Chr(10)
    } else {
        out .= "mov rax, [" . str2 . "]" . Chr(10)
        out .= "cmp rax, [" . str3 . "]" . Chr(10)
        out .= "jl .end_if2_" . STR(ifCount2) . Chr(10)
    }
} else if (InStr(str1, " <= ")) {
    str2 := Trim(StrSplit(str1, " <= ", 1))
    str3 := Trim(StrSplit(str1, " <= ", 2))
    isNum := 0
    if (RegExMatch(str3, "^\d+$")) { isNum := 1 }
    if (isNum = 1) {
        out .= "mov rax, [" . str2 . "]" . Chr(10)
        out .= "cmp rax, " . str3 . Chr(10)
        out .= "jg .end_if2_" . STR(ifCount2) . Chr(10)
    } else {
        out .= "mov rax, [" . str2 . "]" . Chr(10)
        out .= "cmp rax, [" . str3 . "]" . Chr(10)
        out .= "jg .end_if2_" . STR(ifCount2) . Chr(10)
    }
}

}
else if (Trim(A_LoopField) = "ifend2") or (Trim(A_LoopField) = "endif2") {
    out .= ".end_if2_" . STR(ifCount2) . ":" . Chr(10)
    ifCount2++
}
else if (SubStr(StrLower(A_LoopField), 1, 4) = "if3 ") {
    str1 := Trim(StringTrimLeft(A_LoopField, 4)) ; str1
    str1 := StringTrimLeft(str1, 1)
    str1 := StringTrimRight(str1, 1)
    if (InStr(str1, " = ")) {
        str2 := Trim(StrSplit(str1, " = ", 1)) ; str3
        if (RegExMatch(str3, "^\d+$")) {
            isNum := 1
        }
        if (isNum = 1) {
            out .= "mov rax, [" . str2 . "]" . Chr(10) . "cmp rax, " . str3 . Chr(10) . "jne .end_if3_" . STR(ifCount3) . Chr(10)
        }
        else {
            out .= "mov rax, [" . str2 . "]" . Chr(10) . "cmp rax, [" . str3 . "]" . Chr(10) . "jne .end_if3_" . STR(ifCount3) . Chr(10)
        }
    }
    else if (InStr(str1, " != ")) {
        str2 := Trim(StrSplit(str1, " != ", 1)) ; str3
        if (RegExMatch(str3, "^\d+$")) {
            isNum := 1
        }
        if (isNum = 1) {
            out .= "mov rax, [" . str2 . "]" . Chr(10) . "cmp rax, " . str3 . Chr(10) . "je .end_if3_" . STR(ifCount3) . Chr(10)
        }
        else {
            out .= "mov rax, [" . str2 . "]" . Chr(10) . "cmp rax, [" . str3 . "]" . Chr(10) . "je .end_if3_" . STR(ifCount3) . Chr(10)
        }
    }
    ; --- IF3 ---
if (InStr(str1, " > ")) {
    str2 := Trim(StrSplit(str1, " > ", 1))
    str3 := Trim(StrSplit(str1, " > ", 2))
    isNum := 0
    if (RegExMatch(str3, "^\d+$")) { isNum := 1 }
    if (isNum = 1) {
        out .= "mov rax, [" . str2 . "]" . Chr(10)
        out .= "cmp rax, " . str3 . Chr(10)
        out .= "jle .end_if3_" . STR(ifCount3) . Chr(10)
    } else {
        out .= "mov rax, [" . str2 . "]" . Chr(10)
        out .= "cmp rax, [" . str3 . "]" . Chr(10)
        out .= "jle .end_if3_" . STR(ifCount3) . Chr(10)
    }
} else if (InStr(str1, " < ")) {
    str2 := Trim(StrSplit(str1, " < ", 1))
    str3 := Trim(StrSplit(str1, " < ", 2))
    isNum := 0
    if (RegExMatch(str3, "^\d+$")) { isNum := 1 }
    if (isNum = 1) {
        out .= "mov rax, [" . str2 . "]" . Chr(10)
        out .= "cmp rax, " . str3 . Chr(10)
        out .= "jge .end_if3_" . STR(ifCount3) . Chr(10)
    } else {
        out .= "mov rax, [" . str2 . "]" . Chr(10)
        out .= "cmp rax, [" . str3 . "]" . Chr(10)
        out .= "jge .end_if3_" . STR(ifCount3) . Chr(10)
    }
} else if (InStr(str1, " >= ")) {
    str2 := Trim(StrSplit(str1, " >= ", 1))
    str3 := Trim(StrSplit(str1, " >= ", 2))
    isNum := 0
    if (RegExMatch(str3, "^\d+$")) { isNum := 1 }
    if (isNum = 1) {
        out .= "mov rax, [" . str2 . "]" . Chr(10)
        out .= "cmp rax, " . str3 . Chr(10)
        out .= "jl .end_if3_" . STR(ifCount3) . Chr(10)
    } else {
        out .= "mov rax, [" . str2 . "]" . Chr(10)
        out .= "cmp rax, [" . str3 . "]" . Chr(10)
        out .= "jl .end_if3_" . STR(ifCount3) . Chr(10)
    }
} else if (InStr(str1, " <= ")) {
    str2 := Trim(StrSplit(str1, " <= ", 1))
    str3 := Trim(StrSplit(str1, " <= ", 2))
    isNum := 0
    if (RegExMatch(str3, "^\d+$")) { isNum := 1 }
    if (isNum = 1) {
        out .= "mov rax, [" . str2 . "]" . Chr(10)
        out .= "cmp rax, " . str3 . Chr(10)
        out .= "jg .end_if3_" . STR(ifCount3) . Chr(10)
    } else {
        out .= "mov rax, [" . str2 . "]" . Chr(10)
        out .= "cmp rax, [" . str3 . "]" . Chr(10)
        out .= "jg .end_if3_" . STR(ifCount3) . Chr(10)
    }
}

}
else if (Trim(A_LoopField) = "ifend3") or (Trim(A_LoopField) = "endif3") {
    out .= ".end_if3_" . STR(ifCount3) . ":" . Chr(10)
    ifCount3++
}
else if (SubStr(StrLower(A_LoopField), 1, 4) = "if4 ") {
    str1 := Trim(StringTrimLeft(A_LoopField, 4))
    str1 := StringTrimLeft(str1, 1)
    str1 := StringTrimRight(str1, 1)
    if (InStr(str1, " = ")) {
        str2 := Trim(StrSplit(str1, " = ", 1))
        if (RegExMatch(str3, "^\d+$")) {
            isNum := 1
        }
        if (isNum = 1) {
            out .= "mov rax, [" . str2 . "]" . Chr(10) . "cmp rax, " . str3 . Chr(10) . "jne .end_if4_" . STR(ifCount4) . Chr(10)
        }
        else {
            out .= "mov rax, [" . str2 . "]" . Chr(10) . "cmp rax, [" . str3 . "]" . Chr(10) . "jne .end_if4_" . STR(ifCount4) . Chr(10)
        }
    }
    else if (InStr(str1, " != ")) {
        str2 := Trim(StrSplit(str1, " != ", 1))
        if (RegExMatch(str3, "^\d+$")) {
            isNum := 1
        }
        if (isNum = 1) {
            out .= "mov rax, [" . str2 . "]" . Chr(10) . "cmp rax, " . str3 . Chr(10) . "je .end_if4_" . STR(ifCount4) . Chr(10)
        }
        else {
            out .= "mov rax, [" . str2 . "]" . Chr(10) . "cmp rax, [" . str3 . "]" . Chr(10) . "je .end_if4_" . STR(ifCount4) . Chr(10)
        }
    }
    ; --- IF4 ---
if (InStr(str1, " > ")) {
    str2 := Trim(StrSplit(str1, " > ", 1))
    str3 := Trim(StrSplit(str1, " > ", 2))
    isNum := 0
    if (RegExMatch(str3, "^\d+$")) { isNum := 1 }
    if (isNum = 1) {
        out .= "mov rax, [" . str2 . "]" . Chr(10)
        out .= "cmp rax, " . str3 . Chr(10)
        out .= "jle .end_if4_" . STR(ifCount4) . Chr(10)
    } else {
        out .= "mov rax, [" . str2 . "]" . Chr(10)
        out .= "cmp rax, [" . str3 . "]" . Chr(10)
        out .= "jle .end_if4_" . STR(ifCount4) . Chr(10)
    }
} else if (InStr(str1, " < ")) {
    str2 := Trim(StrSplit(str1, " < ", 1))
    str3 := Trim(StrSplit(str1, " < ", 2))
    isNum := 0
    if (RegExMatch(str3, "^\d+$")) { isNum := 1 }
    if (isNum = 1) {
        out .= "mov rax, [" . str2 . "]" . Chr(10)
        out .= "cmp rax, " . str3 . Chr(10)
        out .= "jge .end_if4_" . STR(ifCount4) . Chr(10)
    } else {
        out .= "mov rax, [" . str2 . "]" . Chr(10)
        out .= "cmp rax, [" . str3 . "]" . Chr(10)
        out .= "jge .end_if4_" . STR(ifCount4) . Chr(10)
    }
} else if (InStr(str1, " >= ")) {
    str2 := Trim(StrSplit(str1, " >= ", 1))
    str3 := Trim(StrSplit(str1, " >= ", 2))
    isNum := 0
    if (RegExMatch(str3, "^\d+$")) { isNum := 1 }
    if (isNum = 1) {
        out .= "mov rax, [" . str2 . "]" . Chr(10)
        out .= "cmp rax, " . str3 . Chr(10)
        out .= "jl .end_if4_" . STR(ifCount4) . Chr(10)
    } else {
        out .= "mov rax, [" . str2 . "]" . Chr(10)
        out .= "cmp rax, [" . str3 . "]" . Chr(10)
        out .= "jl .end_if4_" . STR(ifCount4) . Chr(10)
    }
} else if (InStr(str1, " <= ")) {
    str2 := Trim(StrSplit(str1, " <= ", 1))
    str3 := Trim(StrSplit(str1, " <= ", 2))
    isNum := 0
    if (RegExMatch(str3, "^\d+$")) { isNum := 1 }
    if (isNum = 1) {
        out .= "mov rax, [" . str2 . "]" . Chr(10)
        out .= "cmp rax, " . str3 . Chr(10)
        out .= "jg .end_if4_" . STR(ifCount4) . Chr(10)
    } else {
        out .= "mov rax, [" . str2 . "]" . Chr(10)
        out .= "cmp rax, [" . str3 . "]" . Chr(10)
        out .= "jg .end_if4_" . STR(ifCount4) . Chr(10)
    }
}

}
else if (Trim(A_LoopField) = "ifend4") or (Trim(A_LoopField) = "endif4") {
    out .= ".end_if4_" . STR(ifCount4) . ":" . Chr(10)
    ifCount4++
}
else if (SubStr(StrLower(A_LoopField), 1, 4) = "if5 ") {
    str1 := Trim(StringTrimLeft(A_LoopField, 4))
    str1 := StringTrimLeft(str1, 1)
    str1 := StringTrimRight(str1, 1)
    if (InStr(str1, " = ")) {
        str2 := Trim(StrSplit(str1, " = ", 1))
        if (RegExMatch(str3, "^\d+$")) {
            isNum := 1
        }
        if (isNum = 1) {
            out .= "mov rax, [" . str2 . "]" . Chr(10) . "cmp rax, " . str3 . Chr(10) . "jne .end_if5_" . STR(ifCount5) . Chr(10)
        }
        else {
            out .= "mov rax, [" . str2 . "]" . Chr(10) . "cmp rax, [" . str3 . "]" . Chr(10) . "jne .end_if5_" . STR(ifCount5) . Chr(10)
        }
    }
    else if (InStr(str1, " != ")) {
        str2 := Trim(StrSplit(str1, " != ", 1))
        if (RegExMatch(str3, "^\d+$")) {
            isNum := 1
        }
        if (isNum = 1) {
            out .= "mov rax, [" . str2 . "]" . Chr(10) . "cmp rax, " . str3 . Chr(10) . "je .end_if5_" . STR(ifCount5) . Chr(10)
        }
        else {
            out .= "mov rax, [" . str2 . "]" . Chr(10) . "cmp rax, [" . str3 . "]" . Chr(10) . "je .end_if5_" . STR(ifCount5) . Chr(10)
        }
    }
    ; --- IF5 ---
if (InStr(str1, " > ")) {
    str2 := Trim(StrSplit(str1, " > ", 1))
    str3 := Trim(StrSplit(str1, " > ", 2))
    isNum := 0
    if (RegExMatch(str3, "^\d+$")) { isNum := 1 }
    if (isNum = 1) {
        out .= "mov rax, [" . str2 . "]" . Chr(10)
        out .= "cmp rax, " . str3 . Chr(10)
        out .= "jle .end_if5_" . STR(ifCount5) . Chr(10)
    } else {
        out .= "mov rax, [" . str2 . "]" . Chr(10)
        out .= "cmp rax, [" . str3 . "]" . Chr(10)
        out .= "jle .end_if5_" . STR(ifCount5) . Chr(10)
    }
} else if (InStr(str1, " < ")) {
    str2 := Trim(StrSplit(str1, " < ", 1))
    str3 := Trim(StrSplit(str1, " < ", 2))
    isNum := 0
    if (RegExMatch(str3, "^\d+$")) { isNum := 1 }
    if (isNum = 1) {
        out .= "mov rax, [" . str2 . "]" . Chr(10)
        out .= "cmp rax, " . str3 . Chr(10)
        out .= "jge .end_if5_" . STR(ifCount5) . Chr(10)
    } else {
        out .= "mov rax, [" . str2 . "]" . Chr(10)
        out .= "cmp rax, [" . str3 . "]" . Chr(10)
        out .= "jge .end_if5_" . STR(ifCount5) . Chr(10)
    }
} else if (InStr(str1, " >= ")) {
    str2 := Trim(StrSplit(str1, " >= ", 1))
    str3 := Trim(StrSplit(str1, " >= ", 2))
    isNum := 0
    if (RegExMatch(str3, "^\d+$")) { isNum := 1 }
    if (isNum = 1) {
        out .= "mov rax, [" . str2 . "]" . Chr(10)
        out .= "cmp rax, " . str3 . Chr(10)
        out .= "jl .end_if5_" . STR(ifCount5) . Chr(10)
    } else {
        out .= "mov rax, [" . str2 . "]" . Chr(10)
        out .= "cmp rax, [" . str3 . "]" . Chr(10)
        out .= "jl .end_if5_" . STR(ifCount5) . Chr(10)
    }
} else if (InStr(str1, " <= ")) {
    str2 := Trim(StrSplit(str1, " <= ", 1))
    str3 := Trim(StrSplit(str1, " <= ", 2))
    isNum := 0
    if (RegExMatch(str3, "^\d+$")) { isNum := 1 }
    if (isNum = 1) {
        out .= "mov rax, [" . str2 . "]" . Chr(10)
        out .= "cmp rax, " . str3 . Chr(10)
        out .= "jg .end_if5_" . STR(ifCount5) . Chr(10)
    } else {
        out .= "mov rax, [" . str2 . "]" . Chr(10)
        out .= "cmp rax, [" . str3 . "]" . Chr(10)
        out .= "jg .end_if5_" . STR(ifCount5) . Chr(10)
    }
}

}
else if (Trim(A_LoopField) = "ifend5") or (Trim(A_LoopField) = "endif5") {
    out .= ".end_if5_" . STR(ifCount5) . ":" . Chr(10)
    ifCount5++
}
else if (SubStr(StrLower(A_LoopField), 1, 4) = "if6 ") {
    str1 := Trim(StringTrimLeft(A_LoopField, 4))
    str1 := StringTrimLeft(str1, 1)
    str1 := StringTrimRight(str1, 1)
    if (InStr(str1, " = ")) {
        str2 := Trim(StrSplit(str1, " = ", 1)) ; str3
        if (RegExMatch(str3, "^\d+$")) {
            isNum := 1
        }
        if (isNum = 1) {
            out .= "mov rax, [" . str2 . "]" . Chr(10) . "cmp rax, " . str3 . Chr(10) . "jne .end_if6_" . STR(ifCount6) . Chr(10)
        }
        else {
            out .= "mov rax, [" . str2 . "]" . Chr(10) . "cmp rax, [" . str3 . "]" . Chr(10) . "jne .end_if6_" . STR(ifCount6) . Chr(10)
        }
    }
    else if (InStr(str1, " != ")) {
        str2 := Trim(StrSplit(str1, " != ", 1)) ; str3
        if (RegExMatch(str3, "^\d+$")) {
            isNum := 1
        }
        if (isNum = 1) {
            out .= "mov rax, [" . str2 . "]" . Chr(10) . "cmp rax, " . str3 . Chr(10) . "je .end_if6_" . STR(ifCount6) . Chr(10)
        }
        else {
            out .= "mov rax, [" . str2 . "]" . Chr(10) . "cmp rax, [" . str3 . "]" . Chr(10) . "je .end_if6_" . STR(ifCount6) . Chr(10)
        }
    }
    ; --- IF6 ---
if (InStr(str1, " > ")) {
    str2 := Trim(StrSplit(str1, " > ", 1))
    str3 := Trim(StrSplit(str1, " > ", 2))
    isNum := 0
    if (RegExMatch(str3, "^\d+$")) { isNum := 1 }
    if (isNum = 1) {
        out .= "mov rax, [" . str2 . "]" . Chr(10)
        out .= "cmp rax, " . str3 . Chr(10)
        out .= "jle .end_if6_" . STR(ifCount6) . Chr(10)
    } else {
        out .= "mov rax, [" . str2 . "]" . Chr(10)
        out .= "cmp rax, [" . str3 . "]" . Chr(10)
        out .= "jle .end_if6_" . STR(ifCount6) . Chr(10)
    }
} else if (InStr(str1, " < ")) {
    str2 := Trim(StrSplit(str1, " < ", 1))
    str3 := Trim(StrSplit(str1, " < ", 2))
    isNum := 0
    if (RegExMatch(str3, "^\d+$")) { isNum := 1 }
    if (isNum = 1) {
        out .= "mov rax, [" . str2 . "]" . Chr(10)
        out .= "cmp rax, " . str3 . Chr(10)
        out .= "jge .end_if6_" . STR(ifCount6) . Chr(10)
    } else {
        out .= "mov rax, [" . str2 . "]" . Chr(10)
        out .= "cmp rax, [" . str3 . "]" . Chr(10)
        out .= "jge .end_if6_" . STR(ifCount6) . Chr(10)
    }
} else if (InStr(str1, " >= ")) {
    str2 := Trim(StrSplit(str1, " >= ", 1))
    str3 := Trim(StrSplit(str1, " >= ", 2))
    isNum := 0
    if (RegExMatch(str3, "^\d+$")) { isNum := 1 }
    if (isNum = 1) {
        out .= "mov rax, [" . str2 . "]" . Chr(10)
        out .= "cmp rax, " . str3 . Chr(10)
        out .= "jl .end_if6_" . STR(ifCount6) . Chr(10)
    } else {
        out .= "mov rax, [" . str2 . "]" . Chr(10)
        out .= "cmp rax, [" . str3 . "]" . Chr(10)
        out .= "jl .end_if6_" . STR(ifCount6) . Chr(10)
    }
} else if (InStr(str1, " <= ")) {
    str2 := Trim(StrSplit(str1, " <= ", 1))
    str3 := Trim(StrSplit(str1, " <= ", 2))
    isNum := 0
    if (RegExMatch(str3, "^\d+$")) { isNum := 1 }
    if (isNum = 1) {
        out .= "mov rax, [" . str2 . "]" . Chr(10)
        out .= "cmp rax, " . str3 . Chr(10)
        out .= "jg .end_if6_" . STR(ifCount6) . Chr(10)
    } else {
        out .= "mov rax, [" . str2 . "]" . Chr(10)
        out .= "cmp rax, [" . str3 . "]" . Chr(10)
        out .= "jg .end_if6_" . STR(ifCount6) . Chr(10)
    }
}

}
else if (Trim(A_LoopField) = "ifend6") or (Trim(A_LoopField) = "endif6") {
    out .= ".end_if6_" . STR(ifCount6) . ":" . Chr(10)
    ifCount6++
}
else if (SubStr(StrLower(A_LoopField), 1, 4) = "if7 ") {
    str1 := Trim(StringTrimLeft(A_LoopField, 4)) ; str1
    str1 := StringTrimLeft(str1, 1)
    str1 := StringTrimRight(str1, 1)
    if (InStr(str1, " = ")) {
        str2 := Trim(StrSplit(str1, " = ", 1)) ; str3
        if (RegExMatch(str3, "^\d+$")) {
            isNum := 1
        }
        if (isNum = 1) {
            out .= "mov rax, [" . str2 . "]" . Chr(10) . "cmp rax, " . str3 . Chr(10) . "jne .end_if7_" . STR(ifCount7) . Chr(10)
        }
        else {
            out .= "mov rax, [" . str2 . "]" . Chr(10) . "cmp rax, [" . str3 . "]" . Chr(10) . "jne .end_if7_" . STR(ifCount7) . Chr(10)
        }
    }
    else if (InStr(str1, " != ")) {
        str2 := Trim(StrSplit(str1, " != ", 1)) ; str3
        if (RegExMatch(str3, "^\d+$")) {
            isNum := 1
        }
        if (isNum = 1) {
            out .= "mov rax, [" . str2 . "]" . Chr(10) . "cmp rax, " . str3 . Chr(10) . "je .end_if7_" . STR(ifCount7) . Chr(10)
        }
        else {
            out .= "mov rax, [" . str2 . "]" . Chr(10) . "cmp rax, [" . str3 . "]" . Chr(10) . "je .end_if7_" . STR(ifCount7) . Chr(10)
        }
    }
    ; --- IF7 ---
if (InStr(str1, " > ")) {
    str2 := Trim(StrSplit(str1, " > ", 1))
    str3 := Trim(StrSplit(str1, " > ", 2))
    isNum := 0
    if (RegExMatch(str3, "^\d+$")) { isNum := 1 }
    if (isNum = 1) {
        out .= "mov rax, [" . str2 . "]" . Chr(10)
        out .= "cmp rax, " . str3 . Chr(10)
        out .= "jle .end_if7_" . STR(ifCount7) . Chr(10)
    } else {
        out .= "mov rax, [" . str2 . "]" . Chr(10)
        out .= "cmp rax, [" . str3 . "]" . Chr(10)
        out .= "jle .end_if7_" . STR(ifCount7) . Chr(10)
    }
} else if (InStr(str1, " < ")) {
    str2 := Trim(StrSplit(str1, " < ", 1))
    str3 := Trim(StrSplit(str1, " < ", 2))
    isNum := 0
    if (RegExMatch(str3, "^\d+$")) { isNum := 1 }
    if (isNum = 1) {
        out .= "mov rax, [" . str2 . "]" . Chr(10)
        out .= "cmp rax, " . str3 . Chr(10)
        out .= "jge .end_if7_" . STR(ifCount7) . Chr(10)
    } else {
        out .= "mov rax, [" . str2 . "]" . Chr(10)
        out .= "cmp rax, [" . str3 . "]" . Chr(10)
        out .= "jge .end_if7_" . STR(ifCount7) . Chr(10)
    }
} else if (InStr(str1, " >= ")) {
    str2 := Trim(StrSplit(str1, " >= ", 1))
    str3 := Trim(StrSplit(str1, " >= ", 2))
    isNum := 0
    if (RegExMatch(str3, "^\d+$")) { isNum := 1 }
    if (isNum = 1) {
        out .= "mov rax, [" . str2 . "]" . Chr(10)
        out .= "cmp rax, " . str3 . Chr(10)
        out .= "jl .end_if7_" . STR(ifCount7) . Chr(10)
    } else {
        out .= "mov rax, [" . str2 . "]" . Chr(10)
        out .= "cmp rax, [" . str3 . "]" . Chr(10)
        out .= "jl .end_if7_" . STR(ifCount7) . Chr(10)
    }
} else if (InStr(str1, " <= ")) {
    str2 := Trim(StrSplit(str1, " <= ", 1))
    str3 := Trim(StrSplit(str1, " <= ", 2))
    isNum := 0
    if (RegExMatch(str3, "^\d+$")) { isNum := 1 }
    if (isNum = 1) {
        out .= "mov rax, [" . str2 . "]" . Chr(10)
        out .= "cmp rax, " . str3 . Chr(10)
        out .= "jg .end_if7_" . STR(ifCount7) . Chr(10)
    } else {
        out .= "mov rax, [" . str2 . "]" . Chr(10)
        out .= "cmp rax, [" . str3 . "]" . Chr(10)
        out .= "jg .end_if7_" . STR(ifCount7) . Chr(10)
    }
}

}
else if (Trim(A_LoopField) = "ifend7") or (Trim(A_LoopField) = "endif7") {
    out .= ".end_if7_" . STR(ifCount7) . ":" . Chr(10)
    ifCount7++
}
else if (SubStr(StrLower(A_LoopField), 1, 4) = "if8 ") {
    str1 := Trim(StringTrimLeft(A_LoopField, 4)) ; str1
    str1 := StringTrimLeft(str1, 1)
    str1 := StringTrimRight(str1, 1)
    if (InStr(str1, " = ")) {
        str2 := Trim(StrSplit(str1, " = ", 1)) ; str3
        if (RegExMatch(str3, "^\d+$")) {
            isNum := 1
        }
        if (isNum = 1) {
            out .= "mov rax, [" . str2 . "]" . Chr(10) . "cmp rax, " . str3 . Chr(10) . "jne .end_if8_" . STR(ifCount8) . Chr(10)
        }
        else {
            out .= "mov rax, [" . str2 . "]" . Chr(10) . "cmp rax, [" . str3 . "]" . Chr(10) . "jne .end_if8_" . STR(ifCount8) . Chr(10)
        }
    }
    else if (InStr(str1, " != ")) {
        str2 := Trim(StrSplit(str1, " != ", 1)) ; str3
        if (RegExMatch(str3, "^\d+$")) {
            isNum := 1
        }
        if (isNum = 1) {
            out .= "mov rax, [" . str2 . "]" . Chr(10) . "cmp rax, " . str3 . Chr(10) . "je .end_if8_" . STR(ifCount8) . Chr(10)
        }
        else {
            out .= "mov rax, [" . str2 . "]" . Chr(10) . "cmp rax, [" . str3 . "]" . Chr(10) . "je .end_if8_" . STR(ifCount8) . Chr(10)
        }
    }
    ; --- IF8 ---
if (InStr(str1, " > ")) {
    str2 := Trim(StrSplit(str1, " > ", 1))
    str3 := Trim(StrSplit(str1, " > ", 2))
    isNum := 0
    if (RegExMatch(str3, "^\d+$")) { isNum := 1 }
    if (isNum = 1) {
        out .= "mov rax, [" . str2 . "]" . Chr(10)
        out .= "cmp rax, " . str3 . Chr(10)
        out .= "jle .end_if8_" . STR(ifCount8) . Chr(10)
    } else {
        out .= "mov rax, [" . str2 . "]" . Chr(10)
        out .= "cmp rax, [" . str3 . "]" . Chr(10)
        out .= "jle .end_if8_" . STR(ifCount8) . Chr(10)
    }
} else if (InStr(str1, " < ")) {
    str2 := Trim(StrSplit(str1, " < ", 1))
    str3 := Trim(StrSplit(str1, " < ", 2))
    isNum := 0
    if (RegExMatch(str3, "^\d+$")) { isNum := 1 }
    if (isNum = 1) {
        out .= "mov rax, [" . str2 . "]" . Chr(10)
        out .= "cmp rax, " . str3 . Chr(10)
        out .= "jge .end_if8_" . STR(ifCount8) . Chr(10)
    } else {
        out .= "mov rax, [" . str2 . "]" . Chr(10)
        out .= "cmp rax, [" . str3 . "]" . Chr(10)
        out .= "jge .end_if8_" . STR(ifCount8) . Chr(10)
    }
} else if (InStr(str1, " >= ")) {
    str2 := Trim(StrSplit(str1, " >= ", 1))
    str3 := Trim(StrSplit(str1, " >= ", 2))
    isNum := 0
    if (RegExMatch(str3, "^\d+$")) { isNum := 1 }
    if (isNum = 1) {
        out .= "mov rax, [" . str2 . "]" . Chr(10)
        out .= "cmp rax, " . str3 . Chr(10)
        out .= "jl .end_if8_" . STR(ifCount8) . Chr(10)
    } else {
        out .= "mov rax, [" . str2 . "]" . Chr(10)
        out .= "cmp rax, [" . str3 . "]" . Chr(10)
        out .= "jl .end_if8_" . STR(ifCount8) . Chr(10)
    }
} else if (InStr(str1, " <= ")) {
    str2 := Trim(StrSplit(str1, " <= ", 1))
    str3 := Trim(StrSplit(str1, " <= ", 2))
    isNum := 0
    if (RegExMatch(str3, "^\d+$")) { isNum := 1 }
    if (isNum = 1) {
        out .= "mov rax, [" . str2 . "]" . Chr(10)
        out .= "cmp rax, " . str3 . Chr(10)
        out .= "jg .end_if8_" . STR(ifCount8) . Chr(10)
    } else {
        out .= "mov rax, [" . str2 . "]" . Chr(10)
        out .= "cmp rax, [" . str3 . "]" . Chr(10)
        out .= "jg .end_if8_" . STR(ifCount8) . Chr(10)
    }
}

}
else if (Trim(A_LoopField) = "ifend8") or (Trim(A_LoopField) = "endif8") {
    out .= ".end_if8_" . STR(ifCount8) . ":" . Chr(10)
    ifCount8++
}
else if (SubStr(StrLower(A_LoopField), 1, 4) = "if9 ") {
    str1 := Trim(StringTrimLeft(A_LoopField, 4)) ; str1
    str1 := StringTrimLeft(str1, 1)
    str1 := StringTrimRight(str1, 1)
if (InStr(str1, " = ")) {
    str2 := Trim(StrSplit(str1, " = ", 1)) ; str3
    if (RegExMatch(str3, "^\d+$")) {
        isNum := 1
    }
    if (isNum = 1) {
        out .= "mov rax, [" . str2 . "]" . Chr(10) . "cmp rax, " . str3 . Chr(10) . "jne .end_if9_" . STR(ifCount9) . Chr(10)
    }
    else {
        out .= "mov rax, [" . str2 . "]" . Chr(10) . "cmp rax, [" . str3 . "]" . Chr(10) . "jne .end_if9_" . STR(ifCount9) . Chr(10)
    }
}
else if (InStr(str1, " != ")) {
    str2 := Trim(StrSplit(str1, " != ", 1)) ; str3
    if (RegExMatch(str3, "^\d+$")) {
        isNum := 1
    }
    if (isNum = 1) {
        out .= "mov rax, [" . str2 . "]" . Chr(10) . "cmp rax, " . str3 . Chr(10) . "je .end_if9_" . STR(ifCount9) . Chr(10)
    }
    else {
        out .= "mov rax, [" . str2 . "]" . Chr(10) . "cmp rax, [" . str3 . "]" . Chr(10) . "je .end_if9_" . STR(ifCount9) . Chr(10)
    }
}
else if (InStr(str1, " > ")) {
    str2 := Trim(StrSplit(str1, " > ", 1)) ; str3
    if (RegExMatch(str3, "^\d+$")) {
        isNum := 1
    }
    if (isNum = 1) {
        out .= "mov rax, [" . str2 . "]" . Chr(10) . "cmp rax, " . str3 . Chr(10) . "jle .end_if9_" . STR(ifCount9) . Chr(10)
    }
    else {
        out .= "mov rax, [" . str2 . "]" . Chr(10) . "cmp rax, [" . str3 . "]" . Chr(10) . "jle .end_if9_" . STR(ifCount9) . Chr(10)
    }
}
else if (InStr(str1, " < ")) {
    str2 := Trim(StrSplit(str1, " < ", 1)) ; str3
    if (RegExMatch(str3, "^\d+$")) {
        isNum := 1
    }
    if (isNum = 1) {
        out .= "mov rax, [" . str2 . "]" . Chr(10) . "cmp rax, " . str3 . Chr(10) . "jge .end_if9_" . STR(ifCount9) . Chr(10)
    }
    else {
        out .= "mov rax, [" . str2 . "]" . Chr(10) . "cmp rax, [" . str3 . "]" . Chr(10) . "jge .end_if9_" . STR(ifCount9) . Chr(10)
    }
}
else if (InStr(str1, " >= ")) {
    str2 := Trim(StrSplit(str1, " >= ", 1)) ; str3
    if (RegExMatch(str3, "^\d+$")) {
        isNum := 1
    }
    if (isNum = 1) {
        out .= "mov rax, [" . str2 . "]" . Chr(10) . "cmp rax, " . str3 . Chr(10) . "jl .end_if9_" . STR(ifCount9) . Chr(10)
    }
    else {
        out .= "mov rax, [" . str2 . "]" . Chr(10) . "cmp rax, [" . str3 . "]" . Chr(10) . "jl .end_if9_" . STR(ifCount9) . Chr(10)
    }
}
else if (InStr(str1, " <= ")) {
    str2 := Trim(StrSplit(str1, " <= ", 1)) ; str3
    if (RegExMatch(str3, "^\d+$")) {
        isNum := 1
    }
    if (isNum = 1) {
        out .= "mov rax, [" . str2 . "]" . Chr(10) . "cmp rax, " . str3 . Chr(10) . "jg .end_if9_" . STR(ifCount9) . Chr(10)
    }
    else {
        out .= "mov rax, [" . str2 . "]" . Chr(10) . "cmp rax, [" . str3 . "]" . Chr(10) . "jg .end_if9_" . STR(ifCount9) . Chr(10)
    }
}

}
else if (Trim(A_LoopField) = "ifend9") or (Trim(A_LoopField) = "endif9") {
    out .= ".end_if9_" . STR(ifCount9) . ":" . Chr(10)
    ifCount9++
}
else if (SubStr(StrLower(A_LoopField), 1, 5) = "func ") {
str1 := Trim(StringTrimLeft(Trim(A_LoopField), 5))
str2 := ""
Loop, Parse, str1 {
if (A_LoopField = "(") {
break
}
else {
str2 .= A_LoopField
}
}
str2 := Trim(str2)
localVarNum := 1
inFunc := 1

funcArgsCount := (countChars(str1, ",") + 1)


int1 := 0
int2 := 0

if (InStr(str1, ",")) or (InStr(str1, "()") = false) {
funcArgsArr := []
Loop, Parse, str1 {
if (A_LoopField = ")") {
break
}

if (int1 = 1) and (A_LoopField != ",") and (A_LoopField != " ") {
funcArgsArr[int2] := funcArgsArr[int2] . A_LoopField
}

if (A_LoopField = ",") {
funcArgsArr.add("")
int2++
}

if (A_LoopField = "(") {
funcArgsArr.add("")
int1 := 1
}
}
}



funcName := str2
out .= str2 . ":" . Chr(10) . "push rbp" . Chr(10) . "mov rbp, rsp" . Chr(10) . "sub rsp, " . STR(8 + (localVarNum * 8)) . Chr(10)
}
else if (Trim(A_LoopField) = "funcend") {
out .= "." . funcName . "_return:" . Chr(10) . "add rsp, " . STR(8 + (localVarNum * 8)) . Chr(10) . "pop rbp" . Chr(10) . "ret" . Chr(10)
funcCount++
}
else if (Trim(A_LoopField) = "return") {
out .= "jmp ." . funcName . "_return" . Chr(10)
}
else if (SubStr(StrLower(A_LoopField), 1, 7) = "return ") {
str1 := Trim(StringTrimLeft(Trim(A_LoopField), 7))
str2 := str1

if (RegExMatch(str1, "^\d+$")) {
out .= "mov rax, " . str2 . Chr(10) . "jmp ." . funcName . "_return" . Chr(10)
}
else {
out .= "mov rax, [" . str2 . "]" . Chr(10) . "jmp ." . funcName . "_return" . Chr(10)
}


}
else if (SubStr(StrLower(A_LoopField), 1, 4) = "arr ") {
str1 := Trim(StringTrimLeft(Trim(A_LoopField), 4))
arrBss .= "    " . Trim(str1) . " rq 3" . Chr(10)

}
else if (InStr(A_LoopField, ".add ")) {
str1 := Trim(StrSplit(A_LoopField, ".", 1))
str2 := Trim(StrSplit(A_LoopField, ".add", 2))


if (RegExMatch(str2, "^\d+$")) {
str3 := "mov rsi, " . str2 . Chr(10) . "mov rdi, " . str1 . Chr(10)
}
else {
str3 := "mov rsi, [" . str2 . "]" . Chr(10) . "mov rdi, " . str1 . Chr(10)
}

out .= str3 . Chr(10) . "call array_append" . Chr(10)
}
else if (InStr(A_LoopField, ".pop")) {
str1 := Trim(StrSplit(A_LoopField, ".", 1))
str2 := Trim(StrSplit(A_LoopField, ".pop", 2))

str3 := "mov rdi, " . str1 . Chr(10)
out .= str3 . Chr(10) . "call array_pop" . Chr(10)
}
else if (InStr(A_LoopField, ".clear")) {
str1 := Trim(StrSplit(A_LoopField, ".", 1))

out .= "mov rdi, " . str1 . Chr(10) . "call array_clear" . Chr(10)
}
else if (InStr(A_LoopField, ".copy ")) {
str1 := Trim(StrSplit(A_LoopField, ".", 1))
str2 := Trim(StrSplit(A_LoopField, ".copy", 2))

out .= "mov rdi, " . str1 . Chr(10) . "mov rsi, " . str2 . Chr(10) . "call array_copy" . Chr(10)
}
else if (InStr(A_LoopField, ".size")) {
str1 := Trim(StrSplit(A_LoopField, ".", 1))

out .= "mov rax, [" . str1 . " + DynamicArray.size]" . Chr(10)
}
else if (InStr(A_LoopField, ".index ")) {
str1 := Trim(StrSplit(A_LoopField, ".", 1))
str2 := Trim(StrSplit(A_LoopField, ".index", 2))

if (RegExMatch(str2, "^\d+$")) {
str3 := "mov rcx, " . str2 . Chr(10)
}
else {
str3 := "mov rcx, [" . str2 . "]" . Chr(10)
}

out .= str3 . Chr(10) . "mov rbx, [" . str1 . " + DynamicArray.pointer]" . Chr(10) . "mov rax, [rbx + rcx*8]" . Chr(10)
}
else if (InStr(A_LoopField, ".compile ")) {

; arrName.compile outArr

str1 := Trim(StrSplit(A_LoopField, ".", 1)) ; arrName
str2 := Trim(StrSplit(A_LoopField, ".compile", 2)) ; outArr

isDotCompile := 1



out .= "mov rdi, " . str1 . Chr(10) . "call array_pack_to_bytes" . Chr(10) . "mov [source_ptr], rax" . Chr(10) . "mov rdi, [source_ptr]" . Chr(10) . "call compiler_c" . Chr(10) . "mov [asm_code_ptr], rax" . Chr(10) . "mov rdi, " . str2 . Chr(10) . "mov rsi, [asm_code_ptr]" . Chr(10) . "call array_unpack_from_bytes" . Chr(10) . "mov rdi, [source_ptr]" . Chr(10) . "mov rsi, [source_ptr_size]" . Chr(10) . "call free_packed_string" . Chr(10) . "mov rdi, [asm_code_ptr]" . Chr(10) . "call free_string_c" . Chr(10)

}
else if (SubStr(StrLower(A_LoopField), 1, 5) = "goto ") {
    str1 := Trim(StringTrimLeft(A_LoopField, 5))

    out .= "jmp .__HTLL_HTLL_" . str1 . Chr(10)
}
else if (SubStr(StrLower(A_LoopField), 1, 5) = "togo ") {
    str1 := Trim(StringTrimLeft(A_LoopField, 5))

    out .= ".__HTLL_HTLL_" . str1 . ":" . Chr(10)
}




else if (SubStr(StrLower(A_LoopField), 1, 13) = "fileread_arr ") {
    str1 := Trim(StringTrimLeft(A_LoopField, 13))
    str2 := Trim(StrSplit(str1, ",", 1))          ; This is the destination array
    str3 := Trim(StrSplit(str1, ",", 2))          ; This is the filename array

    ; --- THE PURE ASSEMBLY GENERATION ---
    ; Pack the FILENAME array (str3) into a C-string.
    out .= "mov rdi, " . str3 . Chr(10)
    out .= "call array_pack_to_bytes" . Chr(10)
    ; -- THE FIX IS HERE --
    out .= "mov [filename_ptr], rax" . Chr(10)      ; Save the POINTER from RAX
    out .= "mov [filename_ptr_size], rdx" . Chr(10) ; Save the SIZE from RDX

    ; Call fileread_from_ptr with the DESTINATION array (str2) and the new pointer.
    out .= "mov rdi, " . str2 . Chr(10)
    out .= "mov rsi, [filename_ptr]" . Chr(10)
    out .= "call fileread_from_ptr" . Chr(10)

    ; Clean up the temporary C-string pointer using YOUR PURE FUNCTION.
    ; -- THE FIX IS HERE --
    out .= "mov rdi, [filename_ptr]" . Chr(10)      ; Load the POINTER into RDI
    out .= "mov rsi, [filename_ptr_size]" . Chr(10) ; Load the SIZE into RSI
    out .= "call free_packed_string" . Chr(10)      ; Call the shredder
}
else if (SubStr(StrLower(A_LoopField), 1, 15) = "fileappend_arr ") {
    str1 := Trim(StringTrimLeft(A_LoopField, 15))
    str2 := Trim(StrSplit(str1, ",", 1))          ; This is the filename array
    str3 := Trim(StrSplit(str1, ",", 2))          ; This is the source content array

    ; --- THE PURE ASSEMBLY GENERATION ---
    ; Pack the FILENAME array (str2) into a C-string.
    out .= "mov rdi, " . str2 . Chr(10)
    out .= "call array_pack_to_bytes" . Chr(10)
    ; -- THE FIX IS HERE --
    out .= "mov [filename_ptr], rax" . Chr(10)
    out .= "mov [filename_ptr_size], rdx" . Chr(10)

    ; Call fileappend_from_ptr with the new pointer and the CONTENT array (str3).
    out .= "mov rdi, [filename_ptr]" . Chr(10)
    out .= "mov rsi, " . str3 . Chr(10)
    out .= "call fileappend_from_ptr" . Chr(10)

    ; Clean up the temporary C-string pointer using YOUR PURE FUNCTION.
    ; -- THE FIX IS HERE --
    out .= "mov rdi, [filename_ptr]" . Chr(10)
    out .= "mov rsi, [filename_ptr_size]" . Chr(10)
    out .= "call free_packed_string" . Chr(10)
}
else if (SubStr(StrLower(A_LoopField), 1, 15) = "filedelete_arr ") {
    str1 := Trim(StringTrimLeft(A_LoopField, 15)) ; This is the filename array

    ; --- THE PURE ASSEMBLY GENERATION ---
    ; Pack the FILENAME array (str1) into a C-string.
    out .= "mov rdi, " . str1 . Chr(10)
    out .= "call array_pack_to_bytes" . Chr(10)
    ; -- THE FIX IS HERE --
    out .= "mov [filename_ptr], rax" . Chr(10)
    out .= "mov [filename_ptr_size], rdx" . Chr(10)

    ; Call filedelete_from_ptr with the new pointer.
    out .= "mov rdi, [filename_ptr]" . Chr(10)
    out .= "call filedelete_from_ptr" . Chr(10)

    ; Clean up the temporary C-string pointer using YOUR PURE FUNCTION.
    ; -- THE FIX IS HERE --
    out .= "mov rdi, [filename_ptr]" . Chr(10)
    out .= "mov rsi, [filename_ptr_size]" . Chr(10)
    out .= "call free_packed_string" . Chr(10)
}



else if (SubStr(StrLower(A_LoopField), 1, 9) = "fileread ") {
    str1 := Trim(StringTrimLeft(A_LoopField, 9))  ; "dest_array, "path.txt""
    str2 := Trim(StrSplit(str1, ",", 1))          ; The destination array name
    str3 := Trim(StrSplit(str1, ",", 2))          ; The file path string literal

    dot_data_print_temp_strings_count++
    path_label := "FILE_PATH_" . STR(dot_data_print_temp_strings_count)
    dot_data_print_temp_strings .= path_label . " db " . str3 . ", 0" . Chr(10)

    out .= "mov rdi, " . str2 . Chr(10) . "mov rsi, " . path_label . Chr(10) . "call file_read" . Chr(10)
}
else if (SubStr(StrLower(A_LoopField), 1, 11) = "fileappend ") {
    str1 := Trim(StringTrimLeft(A_LoopField, 11)) ; ""path.txt", src_array"
    str2 := Trim(StrSplit(str1, ",", 1))          ; The file path string literal
    str3 := Trim(StrSplit(str1, ",", 2))          ; The source array name

    dot_data_print_temp_strings_count++
    path_label := "FILE_PATH_" . STR(dot_data_print_temp_strings_count)
    dot_data_print_temp_strings .= path_label . " db " . str2 . ", 0" . Chr(10)
    out .= "mov rdi, " . path_label . Chr(10) . "mov rsi, " . str3 . Chr(10) . "call file_append" . Chr(10)
}
else if (SubStr(StrLower(A_LoopField), 1, 11) = "filedelete ") {
    str1 := Trim(StringTrimLeft(A_LoopField, 11)) ; ""path.txt""
    
    dot_data_print_temp_strings_count++
    path_label := "FILE_PATH_" . STR(dot_data_print_temp_strings_count)
    dot_data_print_temp_strings .= path_label . " db " . str1 . ", 0" . Chr(10)

    out .= "mov rdi, " . path_label . Chr(10) . "call file_delete" . Chr(10)
}
else if (SubStr(A_LoopField, 1, 6) = "input ") {
    str1 := Trim(StringTrimLeft(A_LoopField, 6))  ; "dest_array, prompt_array"
    str2 := Trim(StrSplit(str1, ",", 1))          ; The destination array name
    str3 := Trim(StrSplit(str1, ",", 2))          ; The prompt array name

    ; Generate the assembly call
    out .= "mov rdi, " . str2 . Chr(10) . "mov rsi, " . str3 . Chr(10) . "call get_user_input" . Chr(10)
}
else if (InStr(A_LoopField, ".set ")) {
    str1 := Trim(StrSplit(A_LoopField, ".", 1))    ; The array name (e.g., "arr1")
    str2 := Trim(StringTrimLeft(A_LoopField, StrLen(str1) + 5)) ; The rest: "1, 99"
    
    str_index := Trim(StrSplit(str2, ",", 1))    ; The index (e.g., "1")
    str_value := Trim(StrSplit(str2, ",", 2))    ; The new value (e.g., "99")

    out .= "mov rbx, [" . str1 . " + DynamicArray.pointer]" . Chr(10)

    if (RegExMatch(str_index, "^\d+$")) {
        out .= "mov rcx, " . str_index . Chr(10)
    } else {
        out .= "mov rcx, [" . str_index . "]" . Chr(10)
    }

    if (RegExMatch(str_value, "^\d+$")) {
        out .= "mov rsi, " . str_value . Chr(10)
    } else {
        out .= "mov rsi, [" . str_value . "]" . Chr(10)
    }

    out .= "mov [rbx + rcx*8], rsi" . Chr(10)
}
else if (SubStrLastChars(Trim(A_LoopField), 1) = ")") {
str1 := StringTrimRight(Trim(A_LoopField), 1)
str2 := StrSplit(str1, "(", 1)

Loop, Parse, str2, " " {
str3 := A_LoopField
}
str2 := str3

str3 := StrSplit(str1, "(", 2)
str4 := ""  
int5 := 0

int1 := 0

if (Trim(str3) = "") {
int1 := 1
}

Loop, Parse, str3, ", " {
if (RegExMatch(A_LoopField, "^\d+$")) {
str4 .= "push " . A_LoopField . Chr(10)
}
else {
str4 .= "push qword [" . A_LoopField . "]" . Chr(10)
}
int5++
}

if (int1 = 0) {
out .= str4 . "call " . str2 . Chr(10) . "add rsp, " . STR(8 * int5) . Chr(10)
}
else {
out .= str4 . "call " . str2 . Chr(10)
}


}
else {
out .= A_LoopField . Chr(10)
}



Loop, % funcArgsArr.size() {
out := RegExReplace(out, "\b" . Trim(funcArgsArr[A_Index]) . "\b", "rbp + " . STR(8 + ( (funcArgsArr.size() - A_Index) * 8 )))
}

out := StrReplace(out, "']", "'")
out := StrReplace(out, "['", "'")
out := StrReplace(out, "push qword []", "")
out := StrReplace(out, "[A_Index]", "r13")

}
StringTrimRight, code, out, 1


arr str allFuncCALLS
allFuncCALLS.add("array_unpack_from_bytes")
arr str allFuncCALLS_alredy
Loop, Parse, code, `n, `r {

if (SubStr(Trim(A_LoopField), 1, 5) = "call ") {
allFuncCALLS.add(Trim(StringTrimLeft(Trim(A_LoopField), 5)))
}


}

str HTLL_Libs_x86_new := Chr(10)


str temp_funcName := ""
int temp_in_funcName := 0
int canWeGetFunc := 0
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
Loop, Parse, HTLL_Libs_x86, `n, `r {



if (InStr(A_LoopField, "$$$$") = false) and (InStr(A_LoopField, "%%%%") = false) and (temp_in_funcName = 1) and (canWeGetFunc = 1)
{
HTLL_Libs_x86_new .= A_LoopField . Chr(10)
}

if (InStr(A_LoopField, "$$$$")) {
temp_funcName := StringTrimLeft(StringTrimRight(Trim(A_LoopField), 4), 4)
temp_in_funcName := 1


canWeGetFunc := 0
Loop, allFuncCALLS.size() {

if (temp_funcName = allFuncCALLS[A_Index]) {
canWeGetFunc := 1
allFuncCALLS_alredy.add(temp_funcName)
break
}
}
}
else if (InStr(A_LoopField, "%%%%")) {
temp_in_funcName := 0
}
}
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;



allFuncCALLS := []
int anotherVar_INT_HELP_BUILD_IN_FUNCS_INT := 0
str ALoopField := ""
Loop, Parse, HTLL_Libs_x86, `n, `r {
ALoopField := A_LoopField
if (SubStr(Trim(A_LoopField), 1, 5) = "call ") or (SubStr(Trim(A_LoopField), 1, 4) = "jmp ") {
anotherVar_INT_HELP_BUILD_IN_FUNCS_INT := 1
Loop, allFuncCALLS_alredy.size() {
if (allFuncCALLS_alredy[A_Index] = Trim(StringTrimLeft(Trim(ALoopField), 4))) {
anotherVar_INT_HELP_BUILD_IN_FUNCS_INT := 0
}
}
if (anotherVar_INT_HELP_BUILD_IN_FUNCS_INT = 1) {
allFuncCALLS.add(Trim(StringTrimLeft(Trim(ALoopField), 4)))
}

}

}

temp_funcName := ""
temp_in_funcName := 0
canWeGetFunc := 0
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
Loop, Parse, HTLL_Libs_x86, `n, `r {



if (InStr(A_LoopField, "$$$$") = false) and (InStr(A_LoopField, "%%%%") = false) and (temp_in_funcName = 1) and (canWeGetFunc = 1)
{
HTLL_Libs_x86_new .= A_LoopField . Chr(10)
}

if (InStr(A_LoopField, "$$$$")) {
temp_funcName := StringTrimLeft(StringTrimRight(Trim(A_LoopField), 4), 4)
temp_in_funcName := 1


canWeGetFunc := 0
Loop, allFuncCALLS.size() {

if (temp_funcName = allFuncCALLS[A_Index]) {
canWeGetFunc := 1
break
}
}
}
else if (InStr(A_LoopField, "%%%%")) {
temp_in_funcName := 0
}
}
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 






    ; =========================================================================
    ; FINAL FASM OBJECT FILE ASSEMBLY - THE TRUE BLUEPRINT
    ; =========================================================================
    dot_data .= dot_data_print_temp_strings . Chr(10)
    dot_data .= dot_data_ints . Chr(10)
    dot_bss .= dot_bss_str . Chr(10)













str fasm_header := ""
    ; --- FASM OBJECT FILE HEADER & LINKER DIRECTIVES ---
        if (isDotCompile = 1) {
    fasm_header := "format ELF64" . Chr(10)
    fasm_header .= "public _start" . Chr(10)        
        }
        else {
    fasm_header := "format ELF64 executable 3" . Chr(10)
    fasm_header .= "entry _start" . Chr(10)        
        }

    
    if (isDotCompile = 1) {
        fasm_header .= "extrn compiler_c" . Chr(10)
        fasm_header .= "extrn free_string_c" . Chr(10)
    }
    fasm_header .= Chr(10)

    ; --- FASM STRUCTURE DEFINITION ---
    fasm_header .= "    DynamicArray.pointer  = 0" . Chr(10) . "    DynamicArray.size     = 8" . Chr(10) . "    DynamicArray.capacity = 16" . Chr(10) . "    sizeof.DynamicArray   = 24" . Chr(10) . Chr(10)


    
    ; #################### THE FINAL TRUTH ####################
    ; Use simple section names WITH the correct ELF flags for object files.
    ; #########################################################
    str upCode := ""
    ; --- FASM BODY ---

if (isDotCompile = 1) { 
upCode := "section '.data' writeable" . Chr(10) . "    SCALE_FACTOR   dq 1000000" . Chr(10) . "    INITIAL_CAPACITY = 2" . Chr(10) . "    print_buffer   rb 21" . Chr(10) . "    dot            db " . Chr(39) . "." . Chr(39) . Chr(10) . "    minus_sign     db " . Chr(39) . "-" . Chr(39) . " " . Chr(10) . "    nl   db 10" . Chr(10) . dot_data . Chr(10)
upCode .= "section '.bss' writeable" . Chr(10) . "    input_buffer rb 256" . Chr(10) . "    file_read_buffer rb 4096" . Chr(10) . "    input_len    rq 1" . Chr(10) . "    filename_ptr_size  rq 1" . Chr(10) . "    source_ptr      rq 1" . Chr(10) . "    source_ptr_size rq 1" . Chr(10) . "    args_array rq 3" . Chr(10) . "    filename_ptr      rq 1" . Chr(10) . "    asm_code_ptr    rq 1" . Chr(10) . "    print_buffer_n rb 20" . Chr(10) . arrBss . dot_bss
upCode .= "section '.text' executable" . Chr(10) . HTLL_Libs_x86_new . Chr(10)
}
else {
upCode := "segment readable writeable" . Chr(10) . "    SCALE_FACTOR   dq 1000000" . Chr(10) . "    INITIAL_CAPACITY = 2" . Chr(10) . "    print_buffer   rb 21" . Chr(10) . "    dot            db " . Chr(39) . "." . Chr(39) . "" . Chr(10) . "    minus_sign     db " . Chr(39) . "-" . Chr(39) . "" . Chr(10) . "    nl   db 10" . Chr(10) . dot_data . Chr(10)
upCode .= Chr(10) . Chr(10) . "    input_buffer rb 256" . Chr(10) . "    file_read_buffer rb 4096" . Chr(10) . "    input_len    rq 1" . Chr(10) . "    filename_ptr_size  rq 1" . Chr(10) . "    source_ptr      rq 1" . Chr(10) . "    source_ptr_size rq 1" . Chr(10) . "    args_array rq 3" . Chr(10) . "    filename_ptr      rq 1" . Chr(10) . "    asm_code_ptr    rq 1" . Chr(10) . "    print_buffer_n rb 20" . Chr(10) . arrBss . dot_bss
upCode .= "segment readable executable" . Chr(10) . HTLL_Libs_x86_new . Chr(10)
}


    ; --- FASM FOOTER ---
    str downCode := Chr(10) . "    ; --- Exit cleanly ---" . Chr(10) . "    mov rsp, rbp" . Chr(10) . "    pop rbp" . Chr(10) . "    mov rax, 60" . Chr(10) . "    xor rdi, rdi" . Chr(10) . "    syscall" . Chr(10) . ""

    ; --- ASSEMBLE THE FINAL STRING ---
    str codeOUT := ""
    if (seenMain = 0) {
        codeOUT := fasm_header . upCode . main_syntax . out . downCode
    } else {
        codeOUT := fasm_header . upCode . out . downCode
    }





 
 
 
;;;;;;;;;;;;;;;;;;;;;;;;;;
 
 

Loop, % theIdNumOfThe34 {
    if (theIdNumOfThe34 = A_Index + 1) {
        codeOUT := StrReplace(codeOUT, "VYIGUOYIYVIUCFCYIUCFCYIGCYGICFHYFHCTCFTFDFGYGFC" . Chr(65) . Chr(65) . STR(A_Index + 1) . Chr(65) . Chr(65), StrReplace(theIdNumOfThe34theVar[A_Index + 1], keyWordEscpaeChar, "\") . Chr(34))
    } else {
        codeOUT := StrReplace(codeOUT, "VYIGUOYIYVIUCFCYIUCFCYIGCYGICFHYFHCTCFTFDFGYGFC" . Chr(65) . Chr(65) . STR(A_Index + 1) . Chr(65) . Chr(65), StrReplace(theIdNumOfThe34theVar[A_Index + 1], keyWordEscpaeChar, "\"))
    }
}

codeOUT := StrReplace(codeOUT, " [rax]", " rax")

return codeOUT
}
main
str params := Trim(GetParams())
str paramsTemp := ""

if (params = "") {
print("Usage:" . Chr(10) . "./HTLL your_file.htll")
}
else {
Loop, Parse, params, `n, `r {
paramsTemp := Trim(A_LoopField)
if (A_Index = 0) {
FileDelete("finalASM_HTLL_ASM.s")
FileAppend(compiler(FileRead(paramsTemp)), "finalASM_HTLL_ASM.s")
print("Compilation finished: finalASM_HTLL_ASM.s generated.")
}

}
}
