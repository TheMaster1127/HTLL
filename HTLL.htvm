str str0 := ""
str str1 := ""
str str2 := ""
str str3 := ""
str str4 := ""
str str5 := ""
str str6 := ""
str str7 := ""
str str8 := ""
str str9 := ""
str str10 := ""
str str11 := ""
str str12 := ""
str str13 := ""
str str14 := ""
str str15 := ""
str str16 := ""
str str17 := ""
str str18 := ""
str str19 := ""
str str20 := ""
str main_syntax := "" . Chr(10) . "; =============================================================================" . Chr(10) . "; MAIN PROGRAM ENTRY POINT" . Chr(10) . "; =============================================================================" . Chr(10) . "_start:" . Chr(10) . ""

arr str nintArr
func bool isNint(str name) {
    Loop, % nintArr.size() {
        if (Trim(name) = Trim(nintArr[A_Index])) {
            return true
        }
    }
return false
}
func str compiler(str code) {
str out := ""


str dot_data := Chr(10)
str dot_data_print_temp_strings := Chr(10)
int dot_data_print_temp_strings_count := 0
str dot_data_ints := Chr(10)

str dot_bss := Chr(10)
str dot_bss_str := Chr(10)


arr str theIdNumOfThe34theVar
arr str getAllCharForTheFurtureSoIcanAddEscapeChar
str ReplaceFixWhitOutFixDoubleQuotesInsideDoubleQuotes := ""
str str21 := ""
str htCodeOUT754754 := ""
str OutFixDoubleQuotesInsideDoubleQuotes := ""
str keyWordEscpaeChar := "\"
int fixOutFixDoubleQuotesInsideDoubleQuotesFIXok := 0
int removeNexFixkeyWordEscpaeChar := 0
int theIdNumOfThe34 := 0
int areWEinSome34sNum := 0


Loop, Parse, code
{
theIdNumOfThe34theVar.add("")
theIdNumOfThe34theVar.add("")
}

Loop, Parse, code
{
theIdNumOfThe34theVar[A_Index] := theIdNumOfThe34theVar[A_Index] . Chr(34)
getAllCharForTheFurtureSoIcanAddEscapeChar.add(A_LoopField)
}

getAllCharForTheFurtureSoIcanAddEscapeChar.add(" ")

ReplaceFixWhitOutFixDoubleQuotesInsideDoubleQuotes := Chr(34) . "ihuiuuhuuhtheidFor" . str21 . "--" . str21 . "asds" . str21 . "as--" . str21 . "theuhtuwaesphoutr" . Chr(34)


Loop, Parse, code
{

if (A_LoopField = keyWordEscpaeChar) and (getAllCharForTheFurtureSoIcanAddEscapeChar[A_Index + 1] = Chr(34))
{
fixOutFixDoubleQuotesInsideDoubleQuotesFIXok := 1
OutFixDoubleQuotesInsideDoubleQuotes .= ReplaceFixWhitOutFixDoubleQuotesInsideDoubleQuotes
}
else
{
if (fixOutFixDoubleQuotesInsideDoubleQuotesFIXok != 1)
{
OutFixDoubleQuotesInsideDoubleQuotes .= A_LoopField
}
else
{
fixOutFixDoubleQuotesInsideDoubleQuotesFIXok := 0
}
}

}


code := OutFixDoubleQuotesInsideDoubleQuotes

if (keyWordEscpaeChar != Chr(92))
{
code := StrReplace(code, Chr(92), Chr(92) . Chr(92))
}




if (keyWordEscpaeChar = Chr(92))
{
Loop, Parse, code
{
if (A_LoopField = Chr(34))
{
areWEinSome34sNum++
}


if (areWEinSome34sNum = 1) 
{



if (A_LoopField != Chr(34))
{
if (A_LoopField = keyWordEscpaeChar)
{
theIdNumOfThe34theVar[theIdNumOfThe34] := theIdNumOfThe34theVar[theIdNumOfThe34] . Chr(92)
}
else
{
theIdNumOfThe34theVar[theIdNumOfThe34] := theIdNumOfThe34theVar[theIdNumOfThe34] . A_LoopField
}
}
else
{
theIdNumOfThe34++
htCodeOUT754754 .= "VYIGUOYIYVIUCFCYIUCFCYIGCYGICFHYFHCTCFTFDFGYGFC" . Chr(65) . Chr(65) . STR(theIdNumOfThe34) . Chr(65) . Chr(65)
}

}


if (areWEinSome34sNum = 2) or (areWEinSome34sNum = 0)
{
if (A_LoopField != Chr(34))
{
htCodeOUT754754 .= A_LoopField
}

areWEinSome34sNum := 0
}



}

}
else
{

Loop, Parse, code
{
if (A_LoopField = Chr(34))
{
areWEinSome34sNum++
}


if (areWEinSome34sNum = 1)
{



if (A_LoopField != Chr(34))
{
if (A_LoopField = keyWordEscpaeChar) and (keyWordEscpaeChar = getAllCharForTheFurtureSoIcanAddEscapeChar[A_Index + 1])
{
theIdNumOfThe34theVar[theIdNumOfThe34] := theIdNumOfThe34theVar[theIdNumOfThe34] . keyWordEscpaeChar
removeNexFixkeyWordEscpaeChar := 1
}
else if (A_LoopField = keyWordEscpaeChar)
{
if (removeNexFixkeyWordEscpaeChar != 1)
{
theIdNumOfThe34theVar[theIdNumOfThe34] := theIdNumOfThe34theVar[theIdNumOfThe34] . Chr(92)
}
else
{
removeNexFixkeyWordEscpaeChar := 0
}
}
else
{
theIdNumOfThe34theVar[theIdNumOfThe34] := theIdNumOfThe34theVar[theIdNumOfThe34] . A_LoopField
}

}
else
{
theIdNumOfThe34++
htCodeOUT754754 .= "VYIGUOYIYVIUCFCYIUCFCYIGCYGICFHYFHCTCFTFDFGYGFC" . Chr(65) . Chr(65) . STR(theIdNumOfThe34) . Chr(65) . Chr(65)

}

}


if (areWEinSome34sNum = 2) or (areWEinSome34sNum = 0)
{
if (A_LoopField != Chr(34))
{
htCodeOUT754754 .= A_LoopField
}

areWEinSome34sNum := 0
}



}
}






code := htCodeOUT754754

Loop, % theIdNumOfThe34
{
theIdNumOfThe34theVar[A_Index] := theIdNumOfThe34theVar[A_Index] . Chr(34)
}

theIdNumOfThe34theVar.add(Chr(34))







code := StrReplace(code, "{", Chr(10) . "{" . Chr(10))
code := StrReplace(code, "}", Chr(10) . "}" . Chr(10))
Loop, Parse, code, `n, `r
{
out .= Trim(A_LoopField) . Chr(10)
}
StringTrimRight, code, out, 1

str1 := ""
out := ""
Loop, Parse, code, `n, `r {
Loop, Parse, A_LoopField {

if (A_LoopField != ";") {
str1 .= A_LoopField
}
else {
break
}

}

out .= Trim(str1) . Chr(10)
str1 := ""
}
StringTrimRight, code, out, 1




int seenMain := 0
out := ""
Loop, Parse, code, `n, `r {

if (Trim(A_LoopField) = "main") {
seenMain := 1
out .= main_syntax . Chr(10)
}
else {
out .= A_LoopField . Chr(10)
}

}
StringTrimRight, code, out, 1



out := ""
Loop, Parse, code, `n, `r {
if (SubStr(A_LoopField, 1, 4) = "int ") {
str1 := Trim(StringTrimLeft(A_LoopField, 4))



if (InStr(str1, ":="))
{
str2 := Trim(StrSplit(str1, ":=", 1))
str3 := Trim(StrSplit(str1, ":=", 2))

if (RegExMatch(str3, "^\d+$")) {
dot_data_ints .= str2 . ": dq " . str3 . Chr(10)
}
else {
dot_data_ints .= str2 . ": dq 0" . Chr(10)
out .= "mov rdi, [" . str3 . "]" . Chr(10)
out .= "mov [" . str2 . "], rdi" . Chr(10)

}


}
else {

if (InStr(str1, ":=") = false) and (InStr(str1, "+=") = false) and (InStr(str1, "-=") = false) and (InStr(str1, "*=") = false) {
dot_data_ints .= Trim(str1) . ": dq 0" . Chr(10)
}
}



if (InStr(str1, "*="))
{
str2 := Trim(StrSplit(str1, "*=", 1))
str3 := Trim(StrSplit(str1, "*=", 2))
dot_data_ints .= str2 . ": dq 0" . Chr(10)
}
else if (InStr(str1, "+="))
{
str2 := Trim(StrSplit(str1, "+=", 1))
str3 := Trim(StrSplit(str1, "+=", 2))
dot_data_ints .= str2 . ": dq 0" . Chr(10)
}
else if (InStr(str1, "-="))
{
str2 := Trim(StrSplit(str1, "-=", 1))
str3 := Trim(StrSplit(str1, "-=", 2))
dot_data_ints .= str2 . ": dq 0" . Chr(10)
}
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

if (InStr(A_LoopField, " += ")) {


str2 := Trim(StrSplit(str1, "+=", 1))
str3 := Trim(StrSplit(str1, "+=", 2))

if (RegExMatch(str3, "^\d+$")) {
out .= "add qword [" . str2 . "], " . str3 . Chr(10)
}
else {
out .= "mov rdi, [" . str3 . "]" . Chr(10)
out .= "add qword [" . str2 . "], rdi" . Chr(10)
}
}
else if (InStr(A_LoopField, " *= ")) {


    str2 := Trim(StrSplit(str1, "*=", 1))  ; var name
    str3 := Trim(StrSplit(str1, "*=", 2))  ; multiplier

    if (RegExMatch(str3, "^\d+$")) {
        ; *= constant
        out .= "mov rax, [" . str2 . "]" . Chr(10)
        out .= "imul rax, " . str3 . Chr(10)
        out .= "mov [" . str2 . "], rax" . Chr(10)
    }
    else {
        ; *= another variable
        out .= "mov rax, [" . str2 . "]" . Chr(10)
        out .= "imul rax, [" . str3 . "]" . Chr(10)
        out .= "mov [" . str2 . "], rax" . Chr(10)
    }
}
else if (InStr(A_LoopField, " -= ")) {

str2 := Trim(StrSplit(str1, "-=", 1))
str3 := Trim(StrSplit(str1, "-=", 2))

if (RegExMatch(str3, "^\d+$")) {
out .= "sub qword [" . str2 . "], " . str3 . Chr(10)
}
else {
out .= "mov rdi, [" . str3 . "]" . Chr(10)
out .= "sub qword [" . str2 . "], rdi" . Chr(10)
}
}

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

}
else if (SubStr(A_LoopField, 1, 5) = "nint ") {
str1 := Trim(StringTrimLeft(A_LoopField, 5))

if (InStr(str1, " ")) {
nintArr.add(StrSplit(str1, " ", 1))
}
else {
nintArr.add(Trim(str1))
}



if (InStr(str1, ":="))
{
str2 := Trim(StrSplit(str1, ":=", 1))
str3 := Trim(StrSplit(str1, ":=", 2))

if (RegExMatch(str3, "^\d+$")) {
dot_data_ints .= str2 . ": dq " . str3 . Chr(10)
dot_data_ints .= str2 . "_is_negative: dq 0" . Chr(10)
}
else {
dot_data_ints .= str2 . ": dq 0" . Chr(10)
dot_data_ints .= str2 . "_is_negative: dq 0" . Chr(10)
out .= "mov rdi, [" . str3 . "]" . Chr(10)
out .= "mov [" . str2 . "], rdi" . Chr(10)

}


}
else {

if (InStr(str1, ":=") = false) and (InStr(str1, "+=") = false) and (InStr(str1, "-=") = false) and (InStr(str1, "*=") = false) {
dot_data_ints .= Trim(str1) . ": dq 0" . Chr(10)
dot_data_ints .= Trim(str1) . "_is_negative: dq 0" . Chr(10)
}
}



if (InStr(str1, "*="))
{
str2 := Trim(StrSplit(str1, "*=", 1))
str3 := Trim(StrSplit(str1, "*=", 2))
dot_data_ints .= str2 . ": dq 0" . Chr(10)
dot_data_ints .= str2 . "_is_negative: dq 0" . Chr(10)
}
else if (InStr(str1, "+="))
{
str2 := Trim(StrSplit(str1, "+=", 1))
str3 := Trim(StrSplit(str1, "+=", 2))
dot_data_ints .= str2 . ": dq 0" . Chr(10)
dot_data_ints .= str2 . "_is_negative: dq 0" . Chr(10)
}
else if (InStr(str1, "-="))
{
str2 := Trim(StrSplit(str1, "-=", 1))
str3 := Trim(StrSplit(str1, "-=", 2))
dot_data_ints .= str2 . ": dq 0" . Chr(10)
dot_data_ints .= str2 . "_is_negative: dq 0" . Chr(10)
}
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

if (InStr(A_LoopField, " += ")) {


str2 := Trim(StrSplit(str1, "+=", 1))
str3 := Trim(StrSplit(str1, "+=", 2))

if (RegExMatch(str3, "^\d+$")) {
out .= "add qword [" . str2 . "], " . str3 . Chr(10)
out .= "lea rdi, [" . str2 . "]" . Chr(10) . "lea rsi, [" . str2 . "_is_negative]" . Chr(10) . "call is_nint_negative" . Chr(10)
}
else {
out .= "mov rdi, [" . str3 . "]" . Chr(10)
out .= "add qword [" . str2 . "], rdi" . Chr(10)
out .= "lea rdi, [" . str2 . "]" . Chr(10) . "lea rsi, [" . str2 . "_is_negative]" . Chr(10) . "call is_nint_negative" . Chr(10)
}
}
else if (InStr(A_LoopField, " *= ")) {


    str2 := Trim(StrSplit(str1, "*=", 1))  ; var name
    str3 := Trim(StrSplit(str1, "*=", 2))  ; multiplier

    if (RegExMatch(str3, "^\d+$")) {
        ; *= constant
        out .= "mov rax, [" . str2 . "]" . Chr(10)
        out .= "imul rax, " . str3 . Chr(10)
        out .= "mov [" . str2 . "], rax" . Chr(10)
        out .= "lea rdi, [" . str2 . "]" . Chr(10) . "lea rsi, [" . str2 . "_is_negative]" . Chr(10) . "call is_nint_negative" . Chr(10)
    }
    else {
        ; *= another variable
        out .= "mov rax, [" . str2 . "]" . Chr(10)
        out .= "imul rax, [" . str3 . "]" . Chr(10)
        out .= "mov [" . str2 . "], rax" . Chr(10)
        out .= "lea rdi, [" . str2 . "]" . Chr(10) . "lea rsi, [" . str2 . "_is_negative]" . Chr(10) . "call is_nint_negative" . Chr(10)
    }
}
else if (InStr(A_LoopField, " -= ")) {

str2 := Trim(StrSplit(str1, "-=", 1))
str3 := Trim(StrSplit(str1, "-=", 2))

if (RegExMatch(str3, "^\d+$")) {
out .= "sub qword [" . str2 . "], " . str3 . Chr(10)
out .= "lea rdi, [" . str2 . "]" . Chr(10) . "lea rsi, [" . str2 . "_is_negative]" . Chr(10) . "call is_nint_negative" . Chr(10)
}
else {
out .= "mov rdi, [" . str3 . "]" . Chr(10)
out .= "sub qword [" . str2 . "], rdi" . Chr(10)
out .= "lea rdi, [" . str2 . "]" . Chr(10) . "lea rsi, [" . str2 . "_is_negative]" . Chr(10) . "call is_nint_negative" . Chr(10)
}
}

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

}
else if (SubStr(A_LoopField, 1, 4) = "str ") {
str1 := Trim(StringTrimLeft(A_LoopField, 4))


str2 := Trim(StrSplit(str1, "[", 2))
str2 := Trim(StrSplit(str2, "]", 1))
str1 := Trim(StrSplit(str1, "[", 1))

dot_bss_str .= str1 . ": resb " . str2 . Chr(10)


}
else if (InStr(A_LoopField, " := ")) or (InStr(A_LoopField, " += ")) or (InStr(A_LoopField, " -= ")) or (InStr(A_LoopField, " *= ")) {

if (InStr(A_LoopField, " := ")) {

str1 := Trim(A_LoopField)
str2 := Trim(StrSplit(str1, ":=", 1))
str3 := Trim(StrSplit(str1, ":=", 2))

if (RegExMatch(str3, "^\d+$")) {
out .= "mov qword [" . str2 . "], " . str3 . Chr(10)
if (isNint(str2)) {
out .= "lea rdi, [" . str2 . "]" . Chr(10) . "lea rsi, [" . str2 . "_is_negative]" . Chr(10) . "call is_nint_negative" . Chr(10)
}
}
else {
out .= "mov rdi, [" . str3 . "]" . Chr(10)
out .= "mov [" . str2 . "], rdi" . Chr(10)
if (isNint(str2)) {
out .= "lea rdi, [" . str2 . "]" . Chr(10) . "lea rsi, [" . str2 . "_is_negative]" . Chr(10) . "call is_nint_negative" . Chr(10)
}
}
}
else if (InStr(A_LoopField, " += ")) {

str1 := Trim(A_LoopField)
str2 := Trim(StrSplit(str1, "+=", 1))
str3 := Trim(StrSplit(str1, "+=", 2))

if (RegExMatch(str3, "^\d+$")) {
out .= "add qword [" . str2 . "], " . str3 . Chr(10)
if (isNint(str2)) {
out .= "lea rdi, [" . str2 . "]" . Chr(10) . "lea rsi, [" . str2 . "_is_negative]" . Chr(10) . "call is_nint_negative" . Chr(10)
}
}
else {
out .= "mov rdi, [" . str3 . "]" . Chr(10)
out .= "add qword [" . str2 . "], rdi" . Chr(10)
if (isNint(str2)) {
out .= "lea rdi, [" . str2 . "]" . Chr(10) . "lea rsi, [" . str2 . "_is_negative]" . Chr(10) . "call is_nint_negative" . Chr(10)
}
}
}
else if (InStr(A_LoopField, " *= ")) {

    str1 := Trim(A_LoopField)
    str2 := Trim(StrSplit(str1, "*=", 1))  ; var name
    str3 := Trim(StrSplit(str1, "*=", 2))  ; multiplier

    if (RegExMatch(str3, "^\d+$")) {
        ; *= constant
        out .= "mov rax, [" . str2 . "]" . Chr(10)
        out .= "imul rax, " . str3 . Chr(10)
        out .= "mov [" . str2 . "], rax" . Chr(10)
        if (isNint(str2)) {
out .= "lea rdi, [" . str2 . "]" . Chr(10) . "lea rsi, [" . str2 . "_is_negative]" . Chr(10) . "call is_nint_negative" . Chr(10)
}
    }
    else {
        ; *= another variable
        out .= "mov rax, [" . str2 . "]" . Chr(10)
        out .= "imul rax, [" . str3 . "]" . Chr(10)
        out .= "mov [" . str2 . "], rax" . Chr(10)
        if (isNint(str2)) {
out .= "lea rdi, [" . str2 . "]" . Chr(10) . "lea rsi, [" . str2 . "_is_negative]" . Chr(10) . "call is_nint_negative" . Chr(10)
}
    }
}
else if (InStr(A_LoopField, " -= ")) {

str1 := Trim(A_LoopField)
str2 := Trim(StrSplit(str1, "-=", 1))
str3 := Trim(StrSplit(str1, "-=", 2))

if (RegExMatch(str3, "^\d+$")) {
out .= "sub qword [" . str2 . "], " . str3 . Chr(10)
if (isNint(str2)) {
out .= "lea rdi, [" . str2 . "]" . Chr(10) . "lea rsi, [" . str2 . "_is_negative]" . Chr(10) . "call is_nint_negative" . Chr(10)
}
}
else {
out .= "mov rdi, [" . str3 . "]" . Chr(10)
out .= "sub qword [" . str2 . "], rdi" . Chr(10)
if (isNint(str2)) {
out .= "lea rdi, [" . str2 . "]" . Chr(10) . "lea rsi, [" . str2 . "_is_negative]" . Chr(10) . "call is_nint_negative" . Chr(10)
}
}
}


}
else if (InStr(A_LoopField, "++")) {
str1 := Trim(A_LoopField)
StringTrimRight, str1, str1, 2
out .= "inc qword [" . Trim(str1) . "]" . Chr(10)
if (isNint(str1)) {
out .= "lea rdi, [" . str1 . "]" . Chr(10) . "lea rsi, [" . str1 . "_is_negative]" . Chr(10) . "call is_nint_negative" . Chr(10)
}
}
else if (InStr(A_LoopField, "--")) {
str1 := Trim(A_LoopField)
StringTrimRight, str1, str1, 2
out .= "dec qword [" . Trim(str1) . "]" . Chr(10)
if (isNint(str1)) {
out .= "lea rdi, [" . str1 . "]" . Chr(10) . "lea rsi, [" . str1 . "_is_negative]" . Chr(10) . "call is_nint_negative" . Chr(10)
}
}
else if (SubStr(A_LoopField, 1, 6) = "print(") {
str1 := StringTrimLeft(A_LoopField, 6)
StringTrimRight, str1, str1, 1
if (RegExMatch(str1, "^\d+$")) {
out .= "mov rdi, " . Trim(str1) . Chr(10) . "mov rsi, 0" . Chr(10) . "call print_number" . Chr(10)
}
else if (InStr(str1, "VYIGUOYIYVIUCFCYIUCFCYIGCYGICFHYFHCTCFTFDFGYGFC")) {
dot_data_print_temp_strings_count++
dot_data_print_temp_strings .= "ASM_STR_TEMP_PRINT_" . STR(dot_data_print_temp_strings_count) . ": db " . Trim(str1) . ", 10" . Chr(10) . "ASM_STR_TEMP_PRINT_" . STR(dot_data_print_temp_strings_count) . "_len: equ $-" . "ASM_STR_TEMP_PRINT_" . STR(dot_data_print_temp_strings_count) . Chr(10)


out .= "mov rsi, ASM_STR_TEMP_PRINT_" . STR(dot_data_print_temp_strings_count) . Chr(10) . "mov rdx, " . "ASM_STR_TEMP_PRINT_" . STR(dot_data_print_temp_strings_count) . "_len" . Chr(10) . "call print_str" . Chr(10)


}
else {


if (isNint(str1)) {
out .= "mov rdi, [" . Trim(str1) . "]" . Chr(10) . "mov rsi, [" . str2 . "_is_negative]" . Chr(10) . "call print_number" . Chr(10)
}
else {
out .= "mov rdi, [" . Trim(str1) . "]" . Chr(10) . "mov rsi, 0" . Chr(10) . "call print_number" . Chr(10)
}




}

}

}
StringTrimRight, code, out, 1

dot_data .= dot_data_print_temp_strings . Chr(10)
dot_data .= dot_data_ints . Chr(10)

dot_bss .= dot_bss_str . Chr(10)

str upCode := "; This defines a " . Chr(34) . "struct" . Chr(34) . " to make our code readable." . Chr(10) . "struc DynamicArray" . Chr(10) . "    .pointer:   resq 1  ; Offset 0: Holds the pointer to the heap memory" . Chr(10) . "    .size:      resq 1  ; Offset 8: Holds the current number of elements" . Chr(10) . "    .capacity:  resq 1  ; Offset 16: Holds how many elements the block can store" . Chr(10) . "endstruc" . Chr(10) . "" . Chr(10) . "section .data" . Chr(10) . "    SCALE_FACTOR:   dq 1000000" . Chr(10) . "    INITIAL_CAPACITY equ 2  ; Let's use a smaller capacity to test resizing sooner" . Chr(10) . "    print_buffer:   times 21 db 0" . Chr(10) . "    dot:            db '.'" . Chr(10) . "    minus_sign:     db '-'" . Chr(10) . "    nl:   db 10" . Chr(10) . dot_data . Chr(10) . "" . Chr(10) . "section .bss" . Chr(10) . "    print_buffer_n: resb 20" . Chr(10) . "" . dot_bss . "" . Chr(10) . "section .text" . Chr(10) . "global _start" . Chr(10) . "" . Chr(10) . "; =============================================================================" . Chr(10) . "; UTILITY FUNCTIONS (Correct and Properly Formatted)" . Chr(10) . "; =============================================================================" . Chr(10) . "" . Chr(10) . ";-----------------------------------------------------------------------------" . Chr(10) . ";-----------------------------------------------------------------------------" . Chr(10) . "; is_nint_negative: Reads a signed number, updates its corresponding sign" . Chr(10) . ";                   flag, AND converts the original number to its positive" . Chr(10) . ";                   magnitude if it was negative." . Chr(10) . ";" . Chr(10) . "; [In]" . Chr(10) . ";   rdi - Pointer to the nint variable (which holds a signed value)." . Chr(10) . ";   rsi - Pointer to the is_negative flag variable for that nint." . Chr(10) . ";" . Chr(10) . "; [Out]" . Chr(10) . ";   The memory at [rsi] will be overwritten with 0 or 1." . Chr(10) . ";   The memory at [rdi] will be overwritten with its positive magnitude." . Chr(10) . ";-----------------------------------------------------------------------------" . Chr(10) . "is_nint_negative:" . Chr(10) . "    push rbp" . Chr(10) . "    mov rbp, rsp" . Chr(10) . "    push rax" . Chr(10) . "" . Chr(10) . "    ; Load the actual signed value from the first pointer" . Chr(10) . "    mov rax, [rdi]" . Chr(10) . "" . Chr(10) . "    ; Check its sign using the CPU's Sign Flag" . Chr(10) . "    test rax, rax" . Chr(10) . "    jns .is_positive_or_zero    ; Jump if Not Sign" . Chr(10) . "" . Chr(10) . ".is_negative:" . Chr(10) . "    ; The number is negative." . Chr(10) . "    ; 1. Update the flag variable to 1." . Chr(10) . "    mov qword [rsi], 1" . Chr(10) . "    " . Chr(10) . "    ; 2. Negate the value to get its positive magnitude." . Chr(10) . "    neg rax" . Chr(10) . "    " . Chr(10) . "    ; 3. Store the positive magnitude BACK into the original variable." . Chr(10) . "    mov [rdi], rax" . Chr(10) . "    jmp .done" . Chr(10) . "" . Chr(10) . ".is_positive_or_zero:" . Chr(10) . "    ; The number is positive or zero." . Chr(10) . "    ; 1. Update the flag variable to 0." . Chr(10) . "    mov qword [rsi], 0" . Chr(10) . "    ; 2. The value at [rdi] is already its own positive magnitude, so we do nothing to it." . Chr(10) . "" . Chr(10) . ".done:" . Chr(10) . "    pop rax" . Chr(10) . "    pop rbp" . Chr(10) . "    ret" . Chr(10) . "" . Chr(10) . "" . Chr(10) . "; divide_and_store: Performs fixed-point division and stores results in memory." . Chr(10) . "; [In] rdi: dividend_int, rsi: dividend_dec" . Chr(10) . ";      rdx: divisor_int,  rcx: divisor_dec" . Chr(10) . ";      r8:  ptr to result_int, r9: ptr to result_dec" . Chr(10) . ";-----------------------------------------------------------------------------" . Chr(10) . "divide_and_store:" . Chr(10) . "    ; Prologue" . Chr(10) . "    push rbx" . Chr(10) . "    push r12" . Chr(10) . "    push r13" . Chr(10) . "    push r14" . Chr(10) . "    push r15" . Chr(10) . "" . Chr(10) . "    ; --- THE FIX: Save all volatile input arguments immediately ---" . Chr(10) . "    mov r12, rdi            ; Save dividend_int" . Chr(10) . "    mov r13, rsi            ; Save dividend_dec" . Chr(10) . "    mov r14, rdx            ; Save divisor_int (THIS IS THE CRITICAL FIX)" . Chr(10) . "    mov r15, rcx            ; Save divisor_dec" . Chr(10) . "    " . Chr(10) . "    ; --- Step 1: Scale the Dividend ---" . Chr(10) . "    mov rax, r12            ; Use the saved dividend_int" . Chr(10) . "    mov rbx, [SCALE_FACTOR]" . Chr(10) . "    mul rbx" . Chr(10) . "    add rax, r13            ; Add the saved dividend_dec" . Chr(10) . "    mov r12, rax            ; r12 now holds the final scaled dividend" . Chr(10) . "" . Chr(10) . "    ; --- Step 2: Scale the Divisor ---" . Chr(10) . "    mov rax, r14            ; Use the saved divisor_int" . Chr(10) . "    mov rbx, [SCALE_FACTOR]" . Chr(10) . "    mul rbx" . Chr(10) . "    add rax, r15            ; Add the saved divisor_dec" . Chr(10) . "    mov r13, rax            ; r13 now holds the final scaled divisor" . Chr(10) . "" . Chr(10) . "    ; --- Step 3: Perform the main 128-bit division ---" . Chr(10) . "    mov rax, r12            ; Load the scaled dividend" . Chr(10) . "    mov rbx, [SCALE_FACTOR]" . Chr(10) . "    mul rbx" . Chr(10) . "    div r13                 ; Divide by the scaled divisor" . Chr(10) . "    " . Chr(10) . "    ; --- Step 4: De-scale the final result ---" . Chr(10) . "    mov rbx, [SCALE_FACTOR]" . Chr(10) . "    xor rdx, rdx" . Chr(10) . "    div rbx" . Chr(10) . "" . Chr(10) . "    ; --- Step 5: Store the results using the pointers from r8 and r9 ---" . Chr(10) . "    mov [r8], rax           ; Store the integer result" . Chr(10) . "    mov [r9], rdx           ; Store the decimal result" . Chr(10) . "" . Chr(10) . "    ; Epilogue" . Chr(10) . "    pop r15" . Chr(10) . "    pop r14" . Chr(10) . "    pop r13" . Chr(10) . "    pop r12" . Chr(10) . "    pop rbx" . Chr(10) . "    ret" . Chr(10) . "" . Chr(10) . ";-----------------------------------------------------------------------------" . Chr(10) . "; print_div: (Unchanged logic, but now properly formatted)" . Chr(10) . "; [In] rdi: integer part, rsi: decimal part" . Chr(10) . ";-----------------------------------------------------------------------------" . Chr(10) . "print_div:" . Chr(10) . "    ; Prologue" . Chr(10) . "    push rbp" . Chr(10) . "    mov rbp, rsp" . Chr(10) . "    push rbx" . Chr(10) . "    push r12" . Chr(10) . "    push rcx" . Chr(10) . "    push rsi" . Chr(10) . "" . Chr(10) . "    ; --- Print integer part ---" . Chr(10) . "    mov rax, rdi" . Chr(10) . "    lea r12, [print_buffer + 19]" . Chr(10) . "    mov byte [r12], 0" . Chr(10) . "    dec r12" . Chr(10) . "    mov rbx, 10" . Chr(10) . ".int_convert_loop:" . Chr(10) . "    xor rdx, rdx" . Chr(10) . "    div rbx" . Chr(10) . "    add rdx, '0'" . Chr(10) . "    mov [r12], dl" . Chr(10) . "    dec r12" . Chr(10) . "    cmp rax, 0" . Chr(10) . "    jne .int_convert_loop" . Chr(10) . "" . Chr(10) . "    inc r12" . Chr(10) . "    mov rsi, r12" . Chr(10) . "    lea rdx, [print_buffer + 19]" . Chr(10) . "    sub rdx, rsi" . Chr(10) . "    mov rax, 1" . Chr(10) . "    mov rdi, 1" . Chr(10) . "    syscall" . Chr(10) . "" . Chr(10) . "    ; --- Print decimal point ---" . Chr(10) . "    mov rax, 1" . Chr(10) . "    mov rdi, 1" . Chr(10) . "    mov rsi, dot" . Chr(10) . "    mov rdx, 1" . Chr(10) . "    syscall" . Chr(10) . "" . Chr(10) . "    ; --- Print decimal part ---" . Chr(10) . "    pop rax" . Chr(10) . "    lea r12, [print_buffer + 5]" . Chr(10) . "    mov rbx, 10" . Chr(10) . "    mov rcx, 6" . Chr(10) . ".dec_convert_loop:" . Chr(10) . "    xor rdx, rdx" . Chr(10) . "    div rbx" . Chr(10) . "    add rdx, '0'" . Chr(10) . "    mov [r12], dl" . Chr(10) . "    dec r12" . Chr(10) . "    loop .dec_convert_loop" . Chr(10) . "" . Chr(10) . "    mov rax, 1" . Chr(10) . "    mov rdi, 1" . Chr(10) . "    lea rsi, [print_buffer]" . Chr(10) . "    mov rdx, 6" . Chr(10) . "    syscall" . Chr(10) . "" . Chr(10) . "    ; Print a final newline." . Chr(10) . "    mov rax, 1" . Chr(10) . "    mov rdi, 1" . Chr(10) . "    mov rsi, nl" . Chr(10) . "    mov rdx, 1" . Chr(10) . "    syscall" . Chr(10) . "" . Chr(10) . "    ; Epilogue" . Chr(10) . "    pop rcx" . Chr(10) . "    pop r12" . Chr(10) . "    pop rbx" . Chr(10) . "    pop rbp" . Chr(10) . "    ret" . Chr(10) . "" . Chr(10) . "" . Chr(10) . ";-----------------------------------------------------------------------------" . Chr(10) . "; print_number: Prints a number, prepending a '-' sign if requested." . Chr(10) . ";" . Chr(10) . "; [In]" . Chr(10) . ";   rdi - The number to print (as an unsigned, positive magnitude)." . Chr(10) . ";   rsi - The " . Chr(34) . "is_negative" . Chr(34) . " flag. 0 for positive, 1 for negative." . Chr(10) . ";-----------------------------------------------------------------------------" . Chr(10) . "print_number:" . Chr(10) . "    push rbp" . Chr(10) . "    mov rbp, rsp" . Chr(10) . "    push rbx" . Chr(10) . "    push r12" . Chr(10) . "    push rdi        ; Save the number itself (the value from rdi) on the stack." . Chr(10) . "" . Chr(10) . "    ; Check the is_negative flag passed in rsi" . Chr(10) . "    cmp rsi, 0" . Chr(10) . "    je .skip_sign_print" . Chr(10) . "" . Chr(10) . "    ; Flag is 1, so print a minus sign." . Chr(10) . "    ; This is safe because the number is preserved on the stack." . Chr(10) . "    mov rax, 1" . Chr(10) . "    mov rdi, 1" . Chr(10) . "    mov rsi, minus_sign" . Chr(10) . "    mov rdx, 1" . Chr(10) . "    syscall" . Chr(10) . "" . Chr(10) . ".skip_sign_print:" . Chr(10) . "    ; Restore the saved number from the stack directly into RAX," . Chr(10) . "    ; which is the register we need for the division loop." . Chr(10) . "    pop rax" . Chr(10) . "" . Chr(10) . "    ; The conversion loop, which now operates on the correct number in rax." . Chr(10) . "    lea r12, [print_buffer + 19]" . Chr(10) . "    mov byte [r12], 0" . Chr(10) . "    dec r12" . Chr(10) . "    mov rbx, 10" . Chr(10) . ".conversion_loop:" . Chr(10) . "    xor rdx, rdx" . Chr(10) . "    div rbx" . Chr(10) . "    add rdx, '0'" . Chr(10) . "    mov [r12], dl" . Chr(10) . "    dec r12" . Chr(10) . "    cmp rax, 0" . Chr(10) . "    jne .conversion_loop" . Chr(10) . "" . Chr(10) . "    inc r12" . Chr(10) . "    mov rsi, r12" . Chr(10) . "    lea rdx, [print_buffer + 20]" . Chr(10) . "    sub rdx, rsi" . Chr(10) . "    mov rax, 1" . Chr(10) . "    mov rdi, 1" . Chr(10) . "    syscall" . Chr(10) . "" . Chr(10) . "    ; Print a final newline." . Chr(10) . "    mov rax, 1" . Chr(10) . "    mov rdi, 1" . Chr(10) . "    mov rsi, nl" . Chr(10) . "    mov rdx, 1" . Chr(10) . "    syscall" . Chr(10) . "" . Chr(10) . "    ; The stack is balanced because we pushed RDI and popped it into RAX." . Chr(10) . "    pop r12" . Chr(10) . "    pop rbx" . Chr(10) . "    pop rbp" . Chr(10) . "    ret" . Chr(10) . "" . Chr(10) . "print_str:" . Chr(10) . "    push rbp" . Chr(10) . "    mov rbp, rsp" . Chr(10) . "    mov rax, 1" . Chr(10) . "    mov rdi, 1" . Chr(10) . "    ; rsi and rdx are expected to be set by the caller" . Chr(10) . "    syscall" . Chr(10) . "    pop rbp" . Chr(10) . "    ret" . Chr(10) . "" . Chr(10) . ";-----------------------------------------------------------------------------" . Chr(10) . "; input: Reads a line from stdin, handles empty input, removes the trailing" . Chr(10) . ";        newline, and stores the raw string and its length." . Chr(10) . ";" . Chr(10) . "; [In]" . Chr(10) . ";   rdi - Pointer to the buffer where the string should be stored." . Chr(10) . ";   rsi - Pointer to a qword where the length of the clean string will be stored." . Chr(10) . ";-----------------------------------------------------------------------------" . Chr(10) . "input:" . Chr(10) . "    push rbp" . Chr(10) . "    mov rbp, rsp" . Chr(10) . "    push r12" . Chr(10) . "    push r13" . Chr(10) . "" . Chr(10) . "    ; Save the pointers passed as arguments immediately" . Chr(10) . "    mov r12, rdi ; r12 holds pointer to the buffer" . Chr(10) . "    mov r13, rsi ; r13 holds pointer to the length variable" . Chr(10) . "" . Chr(10) . "    ; Correctly set up all registers for the sys_read syscall" . Chr(10) . "    mov rax, 0" . Chr(10) . "    mov rdi, 0" . Chr(10) . "    mov rsi, r12" . Chr(10) . "    mov rdx, 100" . Chr(10) . "    syscall" . Chr(10) . "    ; The program waits here. rax will return with bytes read." . Chr(10) . "" . Chr(10) . "    ; Check if the user entered anything. If they just press Enter, rax will be 1." . Chr(10) . "    ; If they press Ctrl+D, rax will be 0. Both cases mean empty input." . Chr(10) . "    cmp rax, 1" . Chr(10) . "    jle .read_empty     ; Jump if Less or Equal (handles 0 and 1)" . Chr(10) . "" . Chr(10) . "    ; This code only runs for valid input (rax " . Chr(62) . " 1)." . Chr(10) . "    ; The length of the clean string is (bytes_read - 1)." . Chr(10) . "    dec rax" . Chr(10) . "    jmp .store_length   ; Jump to the end to store the calculated length" . Chr(10) . "" . Chr(10) . ".read_empty:" . Chr(10) . "    ; === THE FIX IS HERE ===" . Chr(10) . "    ; If the input was empty, explicitly set the length to 0." . Chr(10) . "    xor rax, rax" . Chr(10) . "" . Chr(10) . ".store_length:" . Chr(10) . "    ; Store the final calculated length (either from dec rax or xor rax)" . Chr(10) . "    ; into the memory location pointed to by r13." . Chr(10) . "    mov [r13], rax" . Chr(10) . "" . Chr(10) . "    pop r13" . Chr(10) . "    pop r12" . Chr(10) . "    pop rbp" . Chr(10) . "    ret" . Chr(10) . "" . Chr(10) . "" . Chr(10) . "; =============================================================================" . Chr(10) . "; DYNAMIC ARRAY LIBRARY FUNCTIONS (Final, Corrected Version)" . Chr(10) . "; =============================================================================" . Chr(10) . "array_append:" . Chr(10) . "    push rbp" . Chr(10) . "    mov rbp, rsp" . Chr(10) . "    push rbx" . Chr(10) . "    push r12" . Chr(10) . "    push r13" . Chr(10) . "    push r14" . Chr(10) . "" . Chr(10) . "    mov r12, rdi             ; R12 = pointer to our array struct" . Chr(10) . "    mov r13, rsi             ; R13 = value we want to add" . Chr(10) . "" . Chr(10) . "    mov rcx, [r12 + DynamicArray.size]" . Chr(10) . "    cmp rcx, [r12 + DynamicArray.capacity]" . Chr(10) . "    jl .has_space" . Chr(10) . "" . Chr(10) . ".resize:" . Chr(10) . "    mov rbx, [r12 + DynamicArray.capacity]" . Chr(10) . "    cmp rbx, 0" . Chr(10) . "    jne .double_it" . Chr(10) . "    mov rbx, INITIAL_CAPACITY" . Chr(10) . "    jmp .capacity_calculated" . Chr(10) . ".double_it:" . Chr(10) . "    shl rbx, 1" . Chr(10) . ".capacity_calculated:" . Chr(10) . "    mov [r12 + DynamicArray.capacity], rbx" . Chr(10) . "" . Chr(10) . "    push r12" . Chr(10) . "    push r13" . Chr(10) . "" . Chr(10) . "    mov r14, rbx" . Chr(10) . "    imul r14, 8" . Chr(10) . "" . Chr(10) . "    mov rax, 9" . Chr(10) . "    mov rdi, 0" . Chr(10) . "    mov rsi, r14" . Chr(10) . "    mov rdx, 3" . Chr(10) . "    mov r10, 34" . Chr(10) . "    mov r8, -1" . Chr(10) . "    mov r9, 0" . Chr(10) . "    syscall" . Chr(10) . "" . Chr(10) . "    cmp rax, 0" . Chr(10) . "    jl .mmap_failed" . Chr(10) . "" . Chr(10) . "    mov r14, rax" . Chr(10) . "" . Chr(10) . "    pop r13" . Chr(10) . "    pop r12" . Chr(10) . "" . Chr(10) . "    mov rsi, [r12 + DynamicArray.pointer]" . Chr(10) . "    cmp rsi, 0" . Chr(10) . "    je .skip_copy" . Chr(10) . "" . Chr(10) . "    mov rcx, [r12 + DynamicArray.size]" . Chr(10) . "    mov rdi, r14" . Chr(10) . "    rep movsq" . Chr(10) . "" . Chr(10) . ".skip_copy:" . Chr(10) . "    mov [r12 + DynamicArray.pointer], r14" . Chr(10) . "    jmp .has_space" . Chr(10) . "" . Chr(10) . ".mmap_failed:" . Chr(10) . "    pop r13" . Chr(10) . "    pop r12" . Chr(10) . "    jmp .append_epilogue" . Chr(10) . "" . Chr(10) . ".has_space:" . Chr(10) . "    mov rbx, [r12 + DynamicArray.pointer]" . Chr(10) . "    mov rcx, [r12 + DynamicArray.size]" . Chr(10) . "" . Chr(10) . "    mov [rbx + rcx * 8], r13" . Chr(10) . "    inc qword [r12 + DynamicArray.size]" . Chr(10) . "" . Chr(10) . ".append_epilogue:" . Chr(10) . "    pop r14" . Chr(10) . "    pop r13" . Chr(10) . "    pop r12" . Chr(10) . "    pop rbx" . Chr(10) . "    pop rbp" . Chr(10) . "    ret" . Chr(10) . "" . Chr(10) . "array_pop:" . Chr(10) . "    push rbp" . Chr(10) . "    mov rbp, rsp" . Chr(10) . "    push rbx" . Chr(10) . "    push rcx" . Chr(10) . "    push r8" . Chr(10) . "" . Chr(10) . "    mov r8, rdi" . Chr(10) . "    mov rcx, [r8 + DynamicArray.size]" . Chr(10) . "    cmp rcx, 0" . Chr(10) . "    je .pop_empty" . Chr(10) . "" . Chr(10) . "    dec rcx" . Chr(10) . "    mov [r8 + DynamicArray.size], rcx" . Chr(10) . "    mov rbx, [r8 + DynamicArray.pointer]" . Chr(10) . "    mov rax, [rbx + rcx * 8]" . Chr(10) . "    jmp .pop_done" . Chr(10) . "" . Chr(10) . ".pop_empty:" . Chr(10) . "    xor rax, rax" . Chr(10) . "" . Chr(10) . ".pop_done:" . Chr(10) . "    pop r8" . Chr(10) . "    pop rcx" . Chr(10) . "    pop rbx" . Chr(10) . "    pop rbp" . Chr(10) . "    ret" . Chr(10) . "" . Chr(10) . ";-----------------------------------------------------------------------------" . Chr(10) . "; array_clear: Clears a dynamic array by setting its size to 0." . Chr(10) . "; [In] rdi: Pointer to the DynamicArray struct." . Chr(10) . ";-----------------------------------------------------------------------------" . Chr(10) . "array_clear:" . Chr(10) . "    push rbp" . Chr(10) . "    mov rbp, rsp" . Chr(10) . "" . Chr(10) . "    ; Set the .size field of the struct pointed to by rdi to 0." . Chr(10) . "    mov qword [rdi + DynamicArray.size], 0" . Chr(10) . "" . Chr(10) . "    pop rbp" . Chr(10) . "    ret" . Chr(10) . "" . Chr(10) . ";-----------------------------------------------------------------------------" . Chr(10) . "" . Chr(10) . "print_char:" . Chr(10) . "    push rbp" . Chr(10) . "    mov rbp, rsp" . Chr(10) . "    sub rsp, 1                  ; reserve 1 byte for char storage" . Chr(10) . "" . Chr(10) . "    mov byte [rsp], dil         ; store char at rsp (safe because reserved)" . Chr(10) . "" . Chr(10) . "    mov rax, 1                 ; sys_write" . Chr(10) . "    mov rdi, 1                 ; stdout" . Chr(10) . "    mov rsi, rsp               ; pointer to char on stack" . Chr(10) . "    mov rdx, 1                 ; length = 1" . Chr(10) . "    syscall" . Chr(10) . "" . Chr(10) . "    add rsp, 1                 ; deallocate local stack space" . Chr(10) . "    pop rbp" . Chr(10) . "    ret" . Chr(10) . "" . Chr(10) . "" . Chr(10) . ""
str downCode := "" . Chr(10) . "    ; --- Exit cleanly ---" . Chr(10) . "    mov rax, 60" . Chr(10) . "    xor rdi, rdi" . Chr(10) . "    syscall" . Chr(10) . ""


str codeOUT := ""

if (seenMain = 0) {
codeOUT := upCode . Chr(10) . main_syntax .  Chr(10) . out . Chr(10) . downCode
}
else {
codeOUT := upCode . Chr(10) . out . Chr(10) . downCode
}




Loop, % theIdNumOfThe34 {
    if (theIdNumOfThe34 = A_Index + 1) {
        codeOUT := StrReplace(codeOUT, "VYIGUOYIYVIUCFCYIUCFCYIGCYGICFHYFHCTCFTFDFGYGFC" . Chr(65) . Chr(65) . STR(A_Index + 1) . Chr(65) . Chr(65), StrReplace(theIdNumOfThe34theVar[A_Index + 1], keyWordEscpaeChar, "\") . Chr(34))
    } else {
        codeOUT := StrReplace(codeOUT, "VYIGUOYIYVIUCFCYIUCFCYIGCYGICFHYFHCTCFTFDFGYGFC" . Chr(65) . Chr(65) . STR(A_Index + 1) . Chr(65) . Chr(65), StrReplace(theIdNumOfThe34theVar[A_Index + 1], keyWordEscpaeChar, "\"))
    }
}


return codeOUT
}
main
str params := Trim(GetParams())
str paramsTemp := ""

if (params = "") {
print("Usage:" . Chr(10) . "./HTLL your_file.htll")
}
else {
Loop, Parse, params, `n, `r {
paramsTemp := Trim(A_LoopField)
if (A_Index = 0) {
FileDelete("finalASM_HTLL_ASM.s")
FileAppend(compiler(FileRead(paramsTemp)), "finalASM_HTLL_ASM.s")
print("Compilation finished: finalASM_HTLL_ASM.s generated.")
}

}
}