
$$$$_kmalloc$$$$

_kmalloc:
    push rbx
    push rdx
    mov rax, [heap_ptr]
    mov rdx, rax
    add rdx, rbx
    mov [heap_ptr], rdx
    mov rax, rdx
    ; Standard bump alloc: Return OLD pointer, increment variable.
    ; My previous logic was: load ptr, save to RDX, add size, save back.
    ; This means RAX returned the END of the block? No.
    
    ; Correct Bump Alloc Logic:
    sub rdx, rbx
    mov rax, rdx
    
    pop rdx
    pop rbx
    ret

%%%%_kmalloc%%%%

$$$$_kfree$$$$
; _kfree: No-op in bump allocator
_kfree:
    ret
%%%%_kfree%%%%

$$$$print_str$$$$
; print_str: Prints string at RSI with length RDX
; [In] RSI: Pointer to string
; [In] RDX: Length of string (This is what your compiler provides!)
print_str:
    push rsi
    push rax
    push rcx
    
    mov rcx, rdx
    cmp rcx, 0
    je .done

.loop:
    mov al, [rsi]
    call print_char
    inc rsi
    dec rcx
    jnz .loop

.done:
    pop rcx
    pop rax
    pop rsi
    ret
%%%%print_str%%%%








$$$$print_char$$$$
print_char:
    push rdi
    push rbx
    push rcx
    push rdx
    push rax
    push rsi
    cmp al, 10
    je .newline
    mov cl, al
    mov rax, [cursor_y]
    mov rbx, 80
    mul rbx
    add rax, [cursor_x]
    shl rax, 1
    
    lea rdi, [video_buffer + rax] ; <--- TARGETS BUFFER
    
    mov byte [rdi], cl
    mov byte [rdi+1], 0x0F
    inc qword [cursor_x]
    cmp qword [cursor_x], 80
    jl .check_scroll
.newline:
    mov qword [cursor_x], 0
    inc qword [cursor_y]
.check_scroll:
    cmp qword [cursor_y], 25
    jl .done
    
    ; Scroll the buffer
    lea rsi, [video_buffer + 160]
    lea rdi, [video_buffer]
    mov rcx, 480
.scroll_loop:
    mov rax, [rsi]
    mov [rdi], rax
    add rsi, 8
    add rdi, 8
    dec rcx
    jnz .scroll_loop
    
    ; Clear last line in buffer
    lea rdi, [video_buffer + 3840]
    mov rax, 0x0F200F200F200F20
    mov rcx, 20
.clear_loop:
    mov [rdi], rax
    add rdi, 8
    loop .clear_loop
    mov qword [cursor_y], 24
    mov qword [cursor_x], 0
.done:
    pop rsi
    pop rax
    pop rdx
    pop rcx
    pop rbx
    pop rdi
    ret
%%%%print_char%%%%













$$$$array_clear$$$$
; array_clear: Resets the array size to 0.
; [In] RDI: Pointer to the array struct.
array_clear:
    mov qword [rdi + 8], 0
    ret
%%%%array_clear%%%%    
$$$$get_user_input$$$$
; ==========================================================
; get_user_input
; [In] RDI: Destination Array (to store input)
; [In] RSI: Prompt Array (to print first)
; ==========================================================
get_user_input:
    push rbx
    push rcx
    push rdx
    push rsi
    push rdi
    push r12
    push r13

    mov r12, rdi
    mov r13, rsi

    ; --- 1. Print Prompt ---
    ; Check if prompt array has data
    mov rax, [r13 + 8]
    cmp rax, 0
    je .read_start

    ; Print the prompt characters
    mov rcx, rax
    mov rbx, [r13]
    xor rdx, rdx
.prompt_loop:
    mov al, [rbx + rdx*8]
    call print_char
    inc rdx
    loop .prompt_loop

.read_start:
    ; --- 2. Read Loop ---
.wait_key:
    ; Read Status
    in al, 0x64  
    ; Data ready?
    test al, 1
    jz .wait_key

    ; Read Scancode
    in al, 0x60
    ; Key release?
    test al, 0x80
    jnz .wait_key

    ; Map Scancode
    lea rdx, [scan_map]
    and rax, 0xFF
    mov al, [rdx + rax]
    
    cmp al, 0
    je .wait_key

    ; Enter
    cmp al, 10
    je .input_done

    ; Backspace
    cmp al, 8
    je .handle_backspace

    ; Valid Char: Echo and Store
    call print_char
    
    ; Append to R12 (Dest Array)
    mov rdi, r12
    ; Pass char in RSI (as per our convention)
    movzx rsi, al
    call array_append
    
    jmp .wait_key

.handle_backspace:
    ; Check if there is anything to delete
    ; r12 holds the input_bufferr pointer
    cmp qword [r12 + 8], 0  
    ; If buffer is empty, do nothing
    je .wait_key

    ; Pop the character from our internal buffer first
    mov rdi, r12
    call array_pop

    ; Now, move the cursor back on screen
    dec qword [cursor_x]
    ; Note: This doesn't handle wrapping to the previous line yet, but works for single lines.

    ; Calculate the video memory address of the character we want to erase
    mov rax, [cursor_y]
    mov rbx, 80
    mul rbx
    add rax, [cursor_x]
    shl rax, 1
    add rax, 0xB8000

    ; Write a black space with white foreground over it
    mov word [rax+0], 0x0F20
    
    jmp .wait_key

.input_done:
    ; Print newline
    mov al, 10
    call print_char

    pop r13
    pop r12
    pop rdi
    pop rsi
    pop rdx
    pop rcx
    pop rbx
    ret
%%%%get_user_input%%%%
    









$$$$print_number$$$$
; print_number: Prints 64-bit number in RAX
print_number:
    push rax
    push rbx
    push rcx
    push rdx
    
    cmp rax, 0
    jne .p_setup
    mov al, '0'
    call print_char
    jmp .p_done

.p_setup:
    mov rbx, 10
    ; digit counter
    xor rcx, rcx

.p_loop:
    xor rdx, rdx
    ; rax / 10
    div rbx
    ; remainder
    push rdx
    inc rcx
    test rax, rax
    jnz .p_loop

.p_print:
    pop rax
    add al, '0'
    call print_char
    loop .p_print

.p_done:
    ; Print newline
    mov al, 10
    call print_char

    pop rdx
    pop rcx
    pop rbx
    pop rax
    ret
%%%%print_number%%%%

$$$$input$$$$
; input: Reads line from PS/2 Keyboard into buffer at RDI
; [In] RDI: Buffer pointer
; [Out] RAX: Length
input:
    push rdi
    push rbx
    ; Count
    mov rbx, 0 

.wait_key:
    ; Read Status Register
    in al, 0x64
    ; Bit 0: Output Buffer Full?
    test al, 1
    ; Spin until data exists
    jz .wait_key

    ; Read Scancode
    in al, 0x60
    
    ; Ignore Key Release (scancodes > 0x80 usually)
    test al, 0x80
    jnz .wait_key

    ; Map Scancode to ASCII
    lea rdx, [scan_map]
    and rax, 0xFF
    mov al, [rdx + rax]
    
    cmp al, 0
    ; Unknown key
    je .wait_key

    ; Enter
    cmp al, 10
    je .finish

    ; Backspace
    cmp al, 8
    je .handle_backspace

    ; Store Char
    mov [rdi], al
    inc rdi
    inc rbx
    
    ; Echo to screen
    call print_char
    jmp .wait_key

.handle_backspace:
    cmp rbx, 0
    je .wait_key
    dec rdi
    dec rbx
    ; Visual backspace
    mov al, 8
    ; (Our print_char logic needs to handle this visually, but for now simple echo)
    call print_char
    jmp .wait_key

.finish:
    ; Null terminate
    mov byte [rdi], 0
    
    ; Print newline
    mov al, 10
    call print_char

    mov rax, rbx
    pop rbx
    pop rdi
    ret
%%%%input%%%%

$$$$array_copy$$$$
; array_copy: 64-bit
; [In] rdi: dest struct ptr, rsi: source struct ptr
array_copy:
    push rdi
    push rsi
    ; Get size
    ; Offset 8 is size (assuming qword structure)
    mov rcx, [rsi + 8] 
    mov [rdi + 8], rcx
    ; capacity
    mov [rdi + 16], rcx
    
    cmp rcx, 0
    je .done

    ; Allocate
    mov rbx, rcx
    ; * 8 (qwords)
    shl rbx, 3
    call _kmalloc
    ; Store pointer
    mov [rdi], rax
    
    ; Copy
    mov rdi, rax
    ; Load source data pointer
    mov rsi, [rsi]
    rep movsq

.done:
    pop rsi
    pop rdi
    ret
%%%%array_copy%%%%

$$$$array_pop$$$$

array_pop:
    ; [In] RDI: Pointer to the array struct.
    ; Check if size is already 0
    cmp qword [rdi + 8], 0  
    je .done
    ; Decrement size
    dec qword [rdi + 8]
.done:
    ret
%%%%array_pop%%%%
$$$$array_append$$$$

array_append:
    push rbx
    push rcx
    push rax

    mov rcx, [rdi + 8]
    mov rbx, [rdi]

    cmp rbx, 0
    jne .store

    mov rbx, 1024 
    call _kmalloc
    mov rbx, rax
    mov [rdi], rbx
    mov qword [rdi+16], 128

.store:
    mov [rbx + rcx*8], rsi
    inc qword [rdi + 8]
    
    pop rax
    pop rcx
    pop rbx
    ret

%%%%array_append%%%%































$$$$_htll_draw$$$$
; --- _htll_draw(x, y, color) ---
; Stack: [RSP]=Ret, [RSP+8]=Color, [RSP+16]=Y, [RSP+24]=X
_htll_draw:
    mov rdx, [rsp+8]    ; Color
    mov rsi, [rsp+16]   ; Y
    mov rdi, [rsp+24]   ; X
    cmp rdi, 80
    jge .done
    cmp rsi, 50
    jge .done
    
    mov rax, rsi
    shr rax, 1          ; Y / 2
    imul rax, 160       ; Row * 160
    imul rbx, rdi, 2    ; X * 2
    add rax, rbx
    add rax, video_buffer ; <--- TARGETS BUFFER
    
    mov bl, byte [rax+1] ; Read existing color from buffer
    test rsi, 1
    jnz .draw_bottom
.draw_top:
    and bl, 240
    and dl, 15
    or bl, dl
    jmp .write_pixel
.draw_bottom:
    and bl, 15
    and dl, 15
    shl dl, 4
    or bl, dl
.write_pixel:
    mov byte [rax+0], 223
    mov byte [rax+1], bl
.done:
    ret
%%%%_htll_draw%%%%

$$$$_htll_clear$$$$
; --- _htll_clear(color) ---
; Stack: [RSP]=Ret, [RSP+8]=Color
_htll_clear:
    mov rdx, [rsp+8]    ; Read Color
    mov rax, rdx
    shl rax, 4
    or rax, rdx
    mov rdx, rax
    
    mov rdi, video_buffer ; <--- TARGETS BUFFER
    mov rcx, 2000
.loop:
    mov byte [rdi], 32 ; Space char
    mov byte [rdi+1], dl
    add rdi, 2
    dec rcx
    jnz .loop
    ret
%%%%_htll_clear%%%%


$$$$draw_all$$$$
; --- The Buffer Swap (Writes to VRAM) ---
draw_all:
    cld
    mov rsi, video_buffer
    mov rdi, 0xB8000
    mov rcx, 500       ; 4000 bytes / 8 bytes per qword = 500 ops
    rep movsq          ; Blit buffer to VRAM
    ret
%%%%draw_all%%%%


$$$$_htll_get_key$$$$
; --- _htll_get_key() ---
_htll_get_key:
    xor rax, rax
    in al, 0x64
    test al, 1
    jz .no_key
    in al, 0x60
    ret
.no_key:
    ret
%%%%_htll_get_key%%%%


$$$$_htll_draw_char$$$$
; --- _htll_draw_char(x, y, char_id, color_id) ---
; ABI: Caller-Cleanup Stack (Peeking)
; Stack: [RSP]=Ret, [RSP+8]=Color, [RSP+16]=Char, [RSP+24]=Y, [RSP+32]=X
_htll_draw_char:
    mov r8,  [rsp+8]     ; Color ID
    mov r9,  [rsp+16]    ; Character ID
    mov rsi, [rsp+24]    ; Y
    mov rdi, [rsp+32]    ; X
    cmp rdi, 80
    jge .done
    cmp rsi, 25
    jge .done
    imul rsi, 160
    imul rdi, 2
    add rsi, rdi
    add rsi, video_buffer ; <--- TARGETS BUFFER
    mov byte [rsi], r9b
    mov byte [rsi+1], r8b
.done:
    ret
%%%%_htll_draw_char%%%%




$$$$bcd2bin$$$$
bcd2bin:
    movzx eax, al      ; AL -> EAX (32-bit)
    mov ecx, eax
    and ecx, 0x0F      ; low nibble
    shr eax, 4         ; high nibble
    imul eax, 10       ; multiply high nibble by 10
    add eax, ecx       ; add low nibble
    ret
%%%%bcd2bin%%%%
$$$$print_two_digits$$$$
; ----------------------------
; Print number in RAX as two digits
; ----------------------------
print_two_digits:
    xor rdx, rdx       ; clear RDX for div
    mov rcx, 10
    div rcx            ; RAX = quotient (tens), RDX = remainder (units)
    mov al, al         ; get quotient in AL
    add al, '0'
    call print_char
    mov al, dl         ; remainder
    add al, '0'
    call print_char
    ret
%%%%print_two_digits%%%%

$$$$_htll_display_clock$$$$
; --- _htll_display_clock(x, y, color, utc_dir, utc_val, is_12h) ---
; ABI: Caller-Cleanup Stack (Peeking)
; Stack: [RSP]=Ret, [RSP+8]=12h, [RSP+16]=utc_val, [RSP+24]=utc_dir, [RSP+32]=color, [RSP+40]=y, [RSP+48]=x
_htll_display_clock:
    ; --- Read Arguments from Stack ---
    mov rdi, [rsp+48]   ; X
    mov rsi, [rsp+40]   ; Y
    mov rdx, [rsp+32]   ; Color
    mov r8,  [rsp+24]   ; UTC Direction (1 for +, 0 for -)
    mov r9,  [rsp+16]   ; UTC Value
    mov r10, [rsp+8]    ; 12h Mode Flag (1 for 12h, 0 for 24h)

    ; --- Set Cursor Position ---
    mov [cursor_x], rdi
    mov [cursor_y], rsi

    ; --- Read RTC and store in registers (local variables) ---
    ; r12 = hour, r13 = minute, r14 = second
    mov al, 4
    out 0x70, al
    in al, 0x71
    call bcd2bin
    mov r12, rax

    mov al, 2
    out 0x70, al
    in al, 0x71
    call bcd2bin
    mov r13, rax

    mov al, 0
    out 0x70, al
    in al, 0x71
    call bcd2bin
    mov r14, rax

    ; --- Apply UTC Offset ---
    cmp r8, 1
    je .utc_add
.utc_sub:
    sub r12, r9
    jmp .utc_done
.utc_add:
    add r12, r9
.utc_done:

    ; Handle hour wrapping
.utc_wrap_check:
    cmp r12, 23
    jg .utc_wrap_sub
    cmp r12, 0
    jl .utc_wrap_add
    jmp .apply_12h_mode
.utc_wrap_sub:
    sub r12, 24
    jmp .utc_wrap_check
.utc_wrap_add:
    add r12, 24
    jmp .utc_wrap_check

    ; --- Apply 12-hour formatting if requested ---
.apply_12h_mode:
    cmp r10, 1
    jne .print_time

    ; It is 12h mode
    cmp r12, 12
    jg .subtract_12
    cmp r12, 0
    je .is_midnight
    jmp .print_time ; Hours 1-12 are fine
.subtract_12:
    sub r12, 12
    jmp .print_time
.is_midnight:
    mov r12, 12 ; 0 hour becomes 12 AM

    ; --- Print the final time ---
.print_time:
    mov rax, r12
    call print_two_digits

    mov al, ':'
    call print_char

    mov rax, r13
    call print_two_digits

    mov al, ':'
    call print_char

    mov rax, r14
    call print_two_digits

    ret
%%%%_htll_display_clock%%%%